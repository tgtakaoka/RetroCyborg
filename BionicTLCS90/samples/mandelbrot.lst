          0 :                            cpu     tlcs90
          0 :                            include "tmp90c802.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :                    ;;; TMP90C802
(1)       0 :                            include "tlcs90.inc"
(2)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(2)       0 :                    ;;; TLCS90
(2)       0 :                    ;;; F Register
(2)       0 : =80                F_SIGN:         equ     10000000B ; set to 1 if negative
(2)       0 : =40                F_ZERO:         equ     01000000B ; set to 1 if zero
(2)       0 : =20                F_INTENB:       equ     00100000B ; set to 1 if interrupt enabled
(2)       0 : =10                F_HALF_CARRY:   equ     00010000B ; set to 1 if carry from bit-3
(2)       0 : =8                 F_EXTENDED:     equ     00001000B ; set to 1 if extended carry
(2)       0 : =4                 F_OVERFLOW:     equ     00000100B ; set to 1 if overflow
(2)       0 : =2                 F_SUBTRACT:     equ     00000010B ; set to 1 if subtraction
(2)       0 : =1                 F_CARRY:        equ     00000001B ; set to 1 if carry
(2)       0 :                    ;;; Interrupt origin
(2)       0 : =0                 ORG_RESET:      equ     0000H   ; RESET
(2)       0 : =10                ORG_SWI:        equ     0010H   ; SWI
(2)       0 : =18                ORG_NMI:        equ     0018H   ; NMI
(2)       0 : =20                ORG_INTWD:      equ     0020H   ; Watchdog
(2)       0 : =28                ORG_INT0:       equ     0028H   ; INT0
(2)       0 : =58                ORG_INT1:       equ     0058H   ; INT1
(1)       0 :                    ;;; Interrupt origin
(1)       0 : =30                ORG_INTT0:      equ     0030H   ; Timer 0
(1)       0 : =38                ORG_INTT1:      equ     0038H   ; Timer 1
(1)       0 : =40                ORG_INTT2:      equ     0040H   ; Timer 2
(1)       0 : =48                ORG_INTT3:      equ     0048H   ; Timer 3
(1)       0 : =70                ORG_INTRX:      equ     0070H   ; Serial receive
(1)       0 : =78                ORG_INTTX:      equ     0078H   ; Serial transmit\
(1)       0 :                    ;;; I/O Port
(1)       0 :                    ;;; Port 0,1,2 are used for data and address bus when #EA=0
(1)       0 :                    ;;; Port P37, P36, P35 are used for bus controls
(1)       0 : =FFC6              P3:     equ     0FFC6H            ; Port 3
(1)       0 : =4                 P32:            equ     00000100B ; Port 3.2
(1)       0 : =FFC7              P3CR:   equ     0FFC7H            ; Port 3 control register
(1)       0 : =80                P3CR_WAIT_ENB:  equ     10000000B ; Enable #WAIT
(1)       0 : =8                 P3CR_TXD:       equ     00001000B ; set to 1 then P33 is TXD
(1)       0 : =2                 P3CR_RXD:       equ     00000010B ; set to 1 then P31 is RXD
(1)       0 : =FFD1              P8CR:   equ     0FFD1H            ; Port 8 control register
(1)       0 : =1                 P8CR_EDGE:      equ     00000001B ; set to 1 then INT0 is edge detection
(1)       0 :                    ;;; Watchdog timer
(1)       0 : =FFD2              WDMOD:  equ     0FFD2H            ; Watchdog timer mode register
(1)       0 : =80                WDMOD_WDTE:     equ     10000000B ; set to 1 then Watchdog timer is enabled
(1)       0 : =FFD3              WDCR:   equ     0FFD3H            ; Watchdog timer control register
(1)       0 : =B1                WDCR_DISABLE:   equ     0B1H      ; Disable watchdog timer
(1)       0 : =4E                WDCR_CLEAR:     equ     04EH      ; Clear watchdog timer
(1)       0 :                    ;;; Interrupt request flag
(1)       0 : =FFC2              IRFL:   equ     0FFC2H
(1)       0 : =6                 IRFL_IRF0_bp:   equ     6       ; INT0 request flag
(1)       0 : =FFC3              IRFH:   equ     0FFC3H
(1)       0 : =4                 IRFH_IRF1_bp:   equ     4       ; INT1 request flag
(1)       0 : =1                 IRFH_IRFRX_bp:  equ     1       ; INTRX request flag
(1)       0 : =0                 IRFH_IRFTX_bp:  equ     0       ; INTTX request flag
(1)       0 :                    ;;; Interrupt enable flag
(1)       0 : =FFE6              INTEL:  equ     0FFE6H
(1)       0 : =4                 INTEL_IE1_bp:   equ     4       ; enable INT1
(1)       0 : =1                 INTEL_IERX_bp:  equ     1       ; enable INTRX
(1)       0 : =0                 INTEL_IETX_bp:  equ     0       ; enable INTTX
(1)       0 : =FFE7              INTEH:  equ     0FFE7H
(1)       0 : =2                 INTEH_IE0_bp:   equ     2       ; enable INT0
(1)       0 :                    ;;; Timer/Serial channel control register
(1)       0 : =FFDB              TRUN:   equ     0FFDBH
(1)       0 : =C0                TRUN_BR9600:    equ     11000000B ; Baud rate 9600bps
(1)       0 : =20                TRUN_PRRUN:     equ     00100000B ; Enable prescaler
(1)       0 :                    ;;; Serial channel mode register
(1)       0 : =FFE9              SCMOD:  equ     0FFE9H
(1)       0 : =20                SCMOD_RXE:      equ     00100000B ; Enable receiving data
(1)       0 : =8                 SCMOD_SM8:      equ     00001000B ; Serial transfer mode 8-bit UART
(1)       0 : =1                 SCMOD_SCBAUD:   equ     00000001B ; Serial transfer clock from baud rate generator
(1)       0 : =3                 SCMOD_SCBAUD2:  equ     00000011B ; Serial transfer clock from 1/2 baud rate generator
(1)       0 :                    ;;; Serial channel control register
(1)       0 : =FFEA              SCCR:   equ     0FFEAH
(1)       0 : =0                 SCCR_PE_DIS:    equ     00000000B ; Disable parity
(1)       0 : =10                SCCR_OERR:      equ     00010000B ; Overrun error flag
(1)       0 : =8                 SCCR_PERR:      equ     00001000B ; Parity error flag
(1)       0 : =4                 SCCR_FERR:      equ     00000100B ; Framing error flag
(1)       0 :                    ;;; Serial transmission/receiving buffer register
(1)       0 : =FFEB              SCBUF:  equ     0FFEBH
          0 :
          0 :                    ;;; i8251 Universal Synchronous/Asynchronous Receiver/Transmitter
          0 : =FFF0              USART:          equ     0FFF0H
          0 : =FFF0              USARTD:         equ     USART+0 ; Receive/Transmit data
          0 : =FFF1              USARTS:         equ     USART+1 ; Srtatus register
          0 : =FFF1              USARTC:         equ     USART+1 ; Control register
          0 : =FFF2              USARTRV:        equ     USART+2 ; Receive interrupt vector (ORG_*)
          0 : =FFF3              USARTTV:        equ     USART+3 ; Transmit interrupt vector (ORG_*)
          0 :                            include "i8251.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; i8251 USART device emulator.
(1)       0 : =6                 MODE_STOP_gp:   equ     6
(1)       0 : =C0                MODE_STOP_gm:   equ     11000000B
(1)       0 : =40                MODE_STOP1_gc:  equ     (1 << MODE_STOP_gp)
(1)       0 : =80                MODE_STOP15_gc: equ     (2 << MODE_STOP_gp)
(1)       0 : =C0                MODE_STOP2_gc:  equ     (3 << MODE_STOP_gp)
(1)       0 : =20                MODE_EVEN_bm:   equ     00100000B
(1)       0 : =10                MODE_PARITY_bm: equ     00010000B
(1)       0 : =2                 MODE_LEN_gp:    equ     2
(1)       0 : =C                 MODE_LEN_gm:    equ     00001100B
(1)       0 : =0                 MODE_LEN5_gc:   equ     (0 << MODE_LEN_gp)
(1)       0 : =4                 MODE_LEN6_gc:   equ     (1 << MODE_LEN_gp)
(1)       0 : =8                 MODE_LEN7_gc:   equ     (2 << MODE_LEN_gp)
(1)       0 : =C                 MODE_LEN8_gc:   equ     (3 << MODE_LEN_gp)
(1)       0 : =0                 MODE_BAUD_gp:   equ     0
(1)       0 : =3                 MODE_BAUD_gm:   equ     00000011B
(1)       0 : =1                 MODE_BAUD_X1:   equ     (1 << MODE_BAUD_gp)
(1)       0 : =2                 MODE_BAUD_X16:  equ (2 << MODE_BAUD_gp)
(1)       0 : =3                 MODE_BAUD_X64:  equ (3 << MODE_BAUD_gp)
(1)       0 :                    ;;; Bit Definition of command register
(1)       0 : =80                CMD_EH_bm:      equ     10000000B   ; Enter hunt mode
(1)       0 : =40                CMD_IR_bm:      equ     01000000B   ; Internal Reset
(1)       0 : =20                CMD_RTS_bm:     equ     00100000B   ; Request To Send
(1)       0 : =10                CMD_ER_bm:      equ     00010000B   ; Error Reset
(1)       0 : =8                 CMD_SBRK_bm:    equ     00001000B   ; Send Break
(1)       0 : =4                 CMD_RxEN_bm:    equ     00000100B   ; Receive Enable
(1)       0 : =2                 CMD_DTR_bm:     equ     00000010B   ; Data Terminal Ready
(1)       0 : =1                 CMD_TxEN_bm:    equ     00000001B   ; Transmit enable
(1)       0 :
(1)       0 :                    ;;; Bit definition of status register
(1)       0 : =80                ST_DSR_bm:      equ     10000000B   ; Data Set Ready
(1)       0 : =40                ST_BRK_bm:      equ     01000000B   ; BREAK detected
(1)       0 : =20                ST_FE_bm:       equ     00100000B   ; Framing Error
(1)       0 : =10                ST_OE_bm:       equ     00010000B   ; Iverrun Error
(1)       0 : =8                 ST_PE_bm:       equ     00001000B   ; Parity Error
(1)       0 : =2                 ST_TxEMPTY_bp:  equ     2           ; Transmitter empty
(1)       0 : =1                 ST_RxRDY_bp:    equ     1           ; Receiver ready
(1)       0 : =0                 ST_TxRDY_bp:    equ     0           ; Transmitter ready
          0 : =27                TXRX_ENABLE     equ     CMD_RTS_bm|CMD_DTR_bm|CMD_RxEN_bm|CMD_TxEN_bm
          0 : =37                RXERR_RESET     equ     TXRX_ENABLE | CMD_ER_bm
          0 :
       2000 :                            org     2000H
       2000 : =80                rx_queue_size:  equ     128
       2000 :                    rx_queue:       ds      rx_queue_size
       2080 : =80                tx_queue_size:  equ     128
       2080 :                    tx_queue:       ds      tx_queue_size
       2100 : 01                 tx_intr_enable: db      1
       2101 :
       1000 :                            org     1000H
       1000 : =1000              stack:  equ     $
       1000 :
          0 :                            org     ORG_RESET
          0 : 1A 00 01                   jp      init
          3 :
         28 :                            org     ORG_INT0
         28 : 1A 5D 01                   jp      isr_intr
         2B :
        100 :                            org     0100H
        100 :                    init:
        100 : 3E 00 10                   ld      sp, stack
        103 : 3C 00 20                   ld      ix, rx_queue
        106 : 30 80                      ld      b, rx_queue_size
        108 : 1C 84 01                   call     queue_init
        10B : 3C 80 20                   ld      ix, tx_queue
        10E : 30 80                      ld      b, tx_queue_size
        110 : 1C 84 01                   call     queue_init
        113 :                    init_usart:
        113 : 37 F1 00                   ld      (USARTC), 0
        116 : 37 F1 00                   ld      (USARTC), 0
        119 : 37 F1 00                   ld      (USARTC), 0     ; safest way to sync mode
        11C :                    ;;; reset
        11C : 37 F1 40                   ld      (USARTC), CMD_IR_bm
        11F : 00                         nop
        120 : 00                         nop
        121 :                    ;;; async 1stop 8data x16
        121 : 37 F1 4E                   ld      (USARTC), MODE_STOP1_gc|MODE_LEN8_gc|MODE_BAUD_X16
        124 : 00                         nop
        125 : 00                         nop
        126 :                    ;;; RTS/DTR, error reset, Rx enable, Tx enable
        126 :                    ;;; enable RxRDY interrupt using RST 5.5
        126 : 37 F1 27                   ld      (USARTC), TXRX_ENABLE
        129 : 37 F2 28                   ld      (USARTRV), ORG_INT0
        12C : 37 F3 00                   ld      (USARTTV), ORG_RESET ; disable TxRDY interrupt
        12F :                    ;;; Enable INT0, INT1
        12F : BA E7                      set     INTEH_IE0_bp, (INTEH)
        131 : 03                         ei
        132 :
        132 : 1C 00 10                   call    mandelbrot
        135 : 36 00                      ld      A, 0
        137 : FF                         swi
        138 :
        138 :                    ;;; Get character
        138 :                    ;;; @return A
        138 :                    ;;; @return CC.C 0 if no character
        138 :                    getchar:
        138 : 54                         push    ix
        139 : 3C 00 20                   ld      ix, rx_queue
        13C : 02                         di
        13D : 1C CB 01                   call    queue_remove
        140 : 03                         ei
        141 : 5C                         pop     ix
        142 : 1E                         ret
        143 :
        143 :                    ;;; Put character
        143 :                    ;;; @param A
        143 :                    putchar:
        143 : 56                         push    af
        144 : 54                         push    ix
        145 : 3C 80 20                   ld      ix, tx_queue
        148 :                    putchar_retry:
        148 : 02                         di
        149 : 1C 9B 01                   call    queue_add
        14C : 03                         ei
        14D : CF F9                      jr      nc, putchar_retry ; branch if queue is full
        14F : 5C                         pop     ix
        150 : 02                         di
        151 : 27 F3                      ld      a, (USARTTV)
        153 : FE 66                      or      a, a
        155 : CE 03                      jr      nz, putchar_exit ; already enabled
        157 : 37 F3 28                   ld      (USARTTV), ORG_INT0
        15A :                    putchar_exit:
        15A : 03                         ei
        15B : 5E                         pop     af
        15C : 1E                         ret
        15D :
        15D :                    isr_intr:
        15D : 27 F1                      ld      a, (USARTS)
        15F : FE A9                      bit     ST_RxRDY_bp, a
        161 : CE 05                      jr      nz, isr_intr_rx
        163 : FE A8                      bit     ST_TxRDY_bp, a
        165 : CE 0C                      jr      nz, isr_intr_tx
        167 : 1F                         reti
        168 :
        168 :                    isr_intr_rx:
        168 : 27 F0                      ld      a, (USARTD)     ; receive character
        16A : 54                         push    ix
        16B : 3C 00 20                   ld      ix, rx_queue
        16E : 1C 9B 01                   call    queue_add
        171 : 5C                         pop     ix
        172 : 1F                         reti
        173 :
        173 :                    isr_intr_tx:
        173 : 54                         push    ix
        174 : 3C 80 20                   ld      ix, tx_queue
        177 : 1C CB 01                   call    queue_remove
        17A : 5C                         pop     ix
        17B : CF 03                      jr      nc, isr_intr_send_empty
        17D : 2F F0                      ld      (USARTD), a     ; send character
        17F : 1F                         reti
        180 :                    isr_intr_send_empty:
        180 : 37 F3 00                   ld      (USARTTV), ORG_RESET ; disable Tx interrupt
        183 : 1F                         reti
        184 :
        184 :                            include "queue.inc"
(1)     184 :                    ;;; [queue] queue structure
(1)     184 : =0                 queue_len:      equ     0       ; queue length
(1)     184 : =1                 queue_size:     equ     1       ; buffer size
(1)     184 : =2                 queue_put:      equ     2       ; queue put index
(1)     184 : =3                 queue_get:      equ     3       ; queue get index
(1)     184 : =4                 queue_buf:      equ     4       ; buffer start offset
(1)     184 :
(1)     184 :                    ;;; [queue] Initialize queue
(1)     184 :                    ;;; @param IX queue work space pointer
(1)     184 :                    ;;; @param B queue work space size
(1)     184 :                    ;;; @clobber B IX
(1)     184 :                    queue_init:
(1)     184 : F4 00 37 00                ld      (ix+queue_len), 0
(1)     188 : F8 6A 04                   sub     b, queue_buf
(1)     18B : F4 01 20                   ld      (ix+queue_size), b
(1)     18E : F8 68 02                   add     b, 2            ; for queue_put and queue_get
(1)     191 : F4 02 3C                   lda     ix, ix+queue_put
(1)     194 :                    queue_init_loop:
(1)     194 : EC 37 00                   ld      (ix), 0
(1)     197 : 94                         inc     ix
(1)     198 : 18 FA                      djnz    queue_init_loop
(1)     19A : 1E                         ret
(1)     19B :
(1)     19B :                    ;;; [queue] Add an element to queue
(1)     19B :                    ;;; @param IX queue work space pointer
(1)     19B :                    ;;; @param A an element
(1)     19B :                    ;;; @return F.C 0 if queue is full
(1)     19B :                    queue_add:
(1)     19B : 56                         push    af              ; save an element
(1)     19C : F0 00 2E                   ld      a, (ix+queue_len)
(1)     19F : F0 01 67                   cp      a, (ix+queue_size)
(1)     1A2 : C7 03                      jr      c, queue_add_store ; queue_len < queue_size
(1)     1A4 : 5E                         pop     af
(1)     1A5 : 0C                         rcf                     ; clear carry
(1)     1A6 : 1E                         ret
(1)     1A7 :                    queue_add_store:
(1)     1A7 : 86                         inc     a               ; queue_len++
(1)     1A8 : F4 00 26                   ld      (ix+queue_len), a
(1)     1AB : 52                         push    hl
(1)     1AC : F4 04 3A                   lda     hl, ix+queue_buf
(1)     1AF : F0 02 2E                   ld      a, (ix+queue_put)
(1)     1B2 : F7 3A                      lda     hl, hl+a
(1)     1B4 : F2 03 2E                   ld      a, (sp+3)       ; get element
(1)     1B7 : EA 26                      ld      (hl), a         ; store element
(1)     1B9 : 5A                         pop     hl
(1)     1BA : F0 02 2E                   ld      a, (ix+queue_put)
(1)     1BD : 86                         inc     a
(1)     1BE : F0 01 67                   cp      a, (ix+queue_size)
(1)     1C1 : C7 02                      jr      c, queue_add_update ; queue_put < queue_size
(1)     1C3 : 36 00                      ld      a, 0                ; wrap around
(1)     1C5 :                    queue_add_update:
(1)     1C5 : F4 02 26                   ld      (ix+queue_put), a
(1)     1C8 : 5E                         pop     af
(1)     1C9 : 0D                         scf                     ; set carry
(1)     1CA : 1E                         ret
(1)     1CB :
(1)     1CB :                    ;;; [queue] Remove an element from queue
(1)     1CB :                    ;;; @param IX queue work space pointer
(1)     1CB :                    ;;; @return A an element
(1)     1CB :                    ;;; @return F.C 0 if queue is empty
(1)     1CB :                    queue_remove:
(1)     1CB : E4 2E                      ld      a, (ix)           ; queue_len
(1)     1CD : FE 66                      or      a, a              ; clear carry
(1)     1CF : FE D6                      ret     z                 ; carry is cleared by |or|
(1)     1D1 : 52                         push    hl
(1)     1D2 : 8E                         dec     a               ; queue_len--
(1)     1D3 : F4 00 26                   ld      (ix+queue_len), a
(1)     1D6 : F4 04 3A                   lda     hl, ix+queue_buf
(1)     1D9 : F0 03 2E                   ld      a, (ix+queue_get)
(1)     1DC : F3 2E                      ld      a, (hl+a)       ; read element
(1)     1DE : 2C                         ld      h, a            ; save element
(1)     1DF : F0 03 2E                   ld      a, (ix+queue_get)
(1)     1E2 : 86                         inc     a
(1)     1E3 : F0 01 67                   cp      a, (ix+queue_size)
(1)     1E6 : C7 02                      jr      c, queue_remove_update ; queue_get < queue_size
(1)     1E8 : 36 00                      ld      a, 0                   ; wrap around
(1)     1EA :                    queue_remove_update:
(1)     1EA : F4 03 26                   ld      (ix+queue_get), a
(1)     1ED : 24                         ld      a, h            ; restore element
(1)     1EE : 5A                         pop     hl
(1)     1EF : 0D                         scf                     ; set carry
(1)     1F0 : 1E                         ret
(1)     1F1 :
(1)     1F1 :                    ;;; Local Variables:
(1)     1F1 :                    ;;; mode: asm
(1)     1F1 :                    ;;; End:
(1)     1F1 :                    ;;; vim: set ft=asm et ts=4 sw=4:
        1F1 :                            include "mandelbrot.inc"
(1)     200 :                            org     0200H
(1)     200 :                    vF:     ds      2
(1)     202 :                    vC:     ds      2
(1)     204 :                    vD:     ds      2
(1)     206 :                    vA:     ds      2
(1)     208 :                    vB:     ds      2
(1)     20A :                    vP:     ds      2
(1)     20C :                    vQ:     ds      2
(1)     20E :                    vS:     ds      2
(1)     210 :                    vT:     ds      2
(1)     212 :                    tmp:    ds      2
(1)     214 :                    vY:     ds      2
(1)     216 :                    vX:     ds      2
(1)     218 :                    vI:     ds      2
(1)     21A :
(1)    1000 :                            org     1000H
(1)    1000 :                    mandelbrot:
(1)    1000 : EB 00 02 3F 32 00          ldw     (vF), 50        ; F=50
(1)    1006 : EB 14 02 3F F4 FF          ldw     (vY), -12       ; Y=-12
(1)    100C :                    loop_y:
(1)    100C : EB 16 02 3F CF FF          ldw     (vX), -49       ; X=-49
(1)    1012 :                    loop_x:
(1)    1012 : E3 16 02 4A                ld      HL, (vX)
(1)    1016 : EB 02 02 42                ld      (vC), HL        ; C=X
(1)    101A : EB 12 02 3F E5 00          ldw     (tmp), 229
(1)    1020 : 3C 02 02                   ld      IX, vC
(1)    1023 : 3D 12 02                   ld      IY, tmp
(1)    1026 : 1C 03 12                   call    mulsi2          ; C=X*229
(1)    1029 : EB 12 02 3F 64 00          ldw     (tmp), 100
(1)    102F : 1C 6D 12                   call    divsi2          ; C=X*229/100
(1)    1032 : E3 14 02 4A                ld      HL, (vY)
(1)    1036 : EB 04 02 42                ld      (vD), HL        ; D=Y
(1)    103A : EB 12 02 3F A0 01          ldw     (tmp), 416
(1)    1040 : 3C 04 02                   ld      IX, vD
(1)    1043 : 1C 03 12                   call    mulsi2          ; D=Y*416
(1)    1046 : EB 12 02 3F 64 00          ldw     (tmp), 100
(1)    104C : 1C 6D 12                   call    divsi2          ; D=Y*416/100
(1)    104F : E3 02 02 4A                ld      HL, (vC)
(1)    1053 : EB 06 02 42                ld      (vA), HL        ; A=C
(1)    1057 : E3 04 02 4A                ld      HL, (vD)
(1)    105B : EB 08 02 42                ld      (vB), HL        ; B=D
(1)    105F : EB 18 02 3F 00 00          ldw     (vI), 0         ; I=0
(1)    1065 :                    loop_i:
(1)    1065 : E3 08 02 4A                ld      HL, (vB)
(1)    1069 : EB 0C 02 42                ld      (vQ), HL        ; Q=B
(1)    106D : 3C 0C 02                   ld      IX, vQ
(1)    1070 : 3D 00 02                   ld      IY, vF
(1)    1073 : 1C 6D 12                   call    divsi2          ; Q=B/F
(1)    1076 : 3C 0E 02                   ld      IX, vS
(1)    1079 : 3D 0C 02                   ld      IY, vQ
(1)    107C : 1C C2 11                   call    negsi2          ; S=-Q
(1)    107F : 3D 00 02                   ld      IY, vF
(1)    1082 : 1C 03 12                   call    mulsi2          ; S=-Q*F
(1)    1085 : 3D 08 02                   ld      IY, vB
(1)    1088 : 1C CB 11                   call    addsi2          ; S=B-Q*F
(1)    108B : E3 08 02 4A                ld      HL, (vB)
(1)    108F : EB 12 02 42                ld      (tmp), HL
(1)    1093 : 3C 12 02                   ld      IX, tmp
(1)    1096 : 1C 03 12                   call    mulsi2          ; tmp=B*B
(1)    1099 : E3 06 02 4A                ld      HL, (vA)
(1)    109D : EB 10 02 42                ld      (vT), HL
(1)    10A1 : 3C 10 02                   ld      IX, vT
(1)    10A4 : 3D 06 02                   ld      IY, vA
(1)    10A7 : 1C 03 12                   call    mulsi2          ; T=A*A
(1)    10AA : 3D 12 02                   ld      IY, tmp
(1)    10AD : 1C D2 11                   call    subsi2          ; T=A*A-B*B
(1)    10B0 : 3D 00 02                   ld      IY, vF
(1)    10B3 : 1C 6D 12                   call    divsi2          ; T=(A*A-B*B)/F
(1)    10B6 : 3D 02 02                   ld      IY, vC
(1)    10B9 : 1C CB 11                   call    addsi2          ; T=(A*A-B*B)/F+C
(1)    10BC : E3 06 02 4A                ld      HL, (vA)
(1)    10C0 : EB 12 02 42                ld      (tmp), HL
(1)    10C4 : 3C 12 02                   ld      IX, tmp
(1)    10C7 : 3D 0E 02                   ld      IY, vS
(1)    10CA : 1C 03 12                   call    mulsi2          ; tmp=A*S
(1)    10CD : 3D 00 02                   ld      IY, vF
(1)    10D0 : 1C 6D 12                   call    divsi2          ; tmp=A*S/F
(1)    10D3 : E3 06 02 4A                ld      HL, (vA)
(1)    10D7 : EB 08 02 42                ld      (vB), HL        ; B=A
(1)    10DB : 3C 08 02                   ld      IX, vB
(1)    10DE : 3D 0C 02                   ld      IY, vQ
(1)    10E1 : 1C 03 12                   call    mulsi2          ; B=A*Q
(1)    10E4 : 3D 12 02                   ld      IY, tmp
(1)    10E7 : 1C CB 11                   call    addsi2          ; B=A*Q+A*S/F
(1)    10EA : 3D 08 02                   ld      IY, vB
(1)    10ED : 1C CB 11                   call    addsi2          ; B=2*(A*Q+A*S/F)
(1)    10F0 : 3D 04 02                   ld      IY, vD
(1)    10F3 : 1C CB 11                   call    addsi2          ; B=2*(A*Q+A*S/F)+D
(1)    10F6 : E3 10 02 4A                ld      HL, (vT)
(1)    10FA : EB 06 02 42                ld      (vA), HL        ; A=T
(1)    10FE : EB 0A 02 42                ld      (vP), HL        ; P=A
(1)    1102 : 3C 0A 02                   ld      IX, vP
(1)    1105 : 3D 00 02                   ld      IY, vF
(1)    1108 : 1C 6D 12                   call    divsi2          ; P=A/F
(1)    110B : E3 08 02 4A                ld      HL, (vB)
(1)    110F : EB 0C 02 42                ld      (vQ), HL
(1)    1113 : 3C 0C 02                   ld      IX, vQ
(1)    1116 : 1C 6D 12                   call    divsi2          ; Q=B/F
(1)    1119 : E3 0C 02 4A                ld      HL, (vQ)
(1)    111D : EB 12 02 42                ld      (tmp), HL
(1)    1121 : 3C 12 02                   ld      IX, tmp
(1)    1124 : 3D 0C 02                   ld      IY, vQ
(1)    1127 : 1C 03 12                   call    mulsi2          ; tmp=Q*Q
(1)    112A : E3 0A 02 4A                ld      HL, (vP)
(1)    112E : EB 10 02 42                ld      (vT), HL
(1)    1132 : 3C 10 02                   ld      IX, vT
(1)    1135 : 3D 0A 02                   ld      IY, vP
(1)    1138 : 1C 03 12                   call    mulsi2          ; T=P*P
(1)    113B : 3D 12 02                   ld      IY, tmp
(1)    113E : 1C CB 11                   call    addsi2          ; T=P*P+Q*Q
(1)    1141 : EB 12 02 3F 04 00          ldw     (tmp), 4
(1)    1147 : 3C 12 02                   ld      IX, tmp
(1)    114A : 3D 10 02                   ld      IY, vT
(1)    114D : 1C D9 11                   call    cmpsi2          ; 4-T
(1)    1150 : EB 70 11 C1                jp      LT, print_i     ; if 4<T
(1)    1154 : E3 18 02 97                incw    (vI)            ; I+=1
(1)    1158 : EB 12 02 3F 10 00          ldw     (tmp), 16
(1)    115E : 3C 18 02                   ld      IX, vI
(1)    1161 : 3D 12 02                   ld      IY, tmp
(1)    1164 : 1C D9 11                   call    cmpsi2
(1)    1167 : EB 65 10 C1                jp      LT, loop_i      ; if I<16
(1)    116B : 36 20                      ld      A, ' '
(1)    116D : 1A 7C 11                   jp      print_char
(1)    1170 :                    print_i:
(1)    1170 : E3 18 02 2E                ld      A, (vI)
(1)    1174 : 6F 0A                      cp      A, 10
(1)    1176 : C7 02                      jr      ULT, print_i2   ; if I<10
(1)    1178 : 68 07                      add     A, 'A'-'0'-10
(1)    117A :                    print_i2:
(1)    117A : 68 30                      add     A, '0'
(1)    117C :                    print_char:     
(1)    117C : 1C 43 01                   call    putchar
(1)    117F : 1C 38 01                   call    getchar
(1)    1182 : CF 05                      jr      nc, next_x
(1)    1184 : FE 66                      or      a, a
(1)    1186 : CE 01                      jr      nz, next_x
(1)    1188 : FF                         swi                     ; break
(1)    1189 :                    next_x:
(1)    1189 : E3 16 02 97                incw    (vX)            ; X+=1
(1)    118D : EB 12 02 3F 1E 00          ldw     (tmp), 30
(1)    1193 : 3C 16 02                   ld      IX, vX
(1)    1196 : 3D 12 02                   ld      IY, tmp
(1)    1199 : 1C D9 11                   call    cmpsi2
(1)    119C : EB 12 10 C1                jp      LT, loop_x      ; if X<30
(1)    11A0 : 36 0D                      ld      A, 0DH
(1)    11A2 : 1C 43 01                   call    putchar
(1)    11A5 : 36 0A                      ld      A, 0AH
(1)    11A7 : 1C 43 01                   call    putchar
(1)    11AA : E3 14 02 97                incw    (vY)              ; Y+=1
(1)    11AE : EB 12 02 3F 0D 00          ldw     (tmp), 13
(1)    11B4 : 3C 14 02                   ld      IX, vY
(1)    11B7 : 3D 12 02                   ld      IY, tmp
(1)    11BA : 1C D9 11                   call    cmpsi2
(1)    11BD : EB 0C 10 C1                jp      LT, loop_y      ; if X<13
(1)    11C1 : 1E                         ret
(1)    11C2 :
(1)    11C2 :                    ;;; Local Variables:
(1)    11C2 :                    ;;; mode: asm
(1)    11C2 :                    ;;; End:
(1)    11C2 :                    ;;; vim: set ft=asm et ts=4 sw=4:
       11C2 :                            include "arith.inc"
(1)    11C2 :                            cpu     tlcs90
(1)    11C2 :
(1)    11C2 :                    ;;; Negation; result = -value
(1)    11C2 :                    ;;; @param @IX: result
(1)    11C2 :                    ;;; @param @IY: value
(1)    11C2 :                    ;;; @clobber HL
(1)    11C2 :                    negsi2:
(1)    11C2 : E5 4A                      ld      HL, (IY)
(1)    11C4 : 7D FF FF                   xor     HL, 0FFFFH
(1)    11C7 : 92                         inc     HL
(1)    11C8 : EC 42                      ld      (IX), HL
(1)    11CA : 1E                         ret
(1)    11CB :
(1)    11CB :                    ;;; Signed addition: summand += addend
(1)    11CB :                    ;;; @param @IX: summand
(1)    11CB :                    ;;; @param @IY: addend
(1)    11CB :                    ;;; @clobber HL
(1)    11CB :                    addsi2:
(1)    11CB : E4 4A                      ld      HL, (IX)
(1)    11CD : E5 70                      add     HL, (IY)
(1)    11CF : EC 42                      ld      (IX), HL
(1)    11D1 : 1E                         ret
(1)    11D2 :
(1)    11D2 :                    ;;; Singed subtraction: minuend -= subtrahend
(1)    11D2 :                    ;;; @param @IX: minuend
(1)    11D2 :                    ;;; @param @IY: subtrahend
(1)    11D2 :                    ;;; @clobber HL
(1)    11D2 :                    subsi2:
(1)    11D2 : E4 4A                      ld      HL, (IX)
(1)    11D4 : E5 72                      sub     HL, (IY)
(1)    11D6 : EC 42                      ld      (IX), HL
(1)    11D8 : 1E                         ret
(1)    11D9 :
(1)    11D9 :                    ;;; Signed comparison: minuend - subtrahend
(1)    11D9 :                    ;;; @param @IX: minuend
(1)    11D9 :                    ;;; @param @IY: subtrahend
(1)    11D9 :                    ;;; @return F.S, F.V
(1)    11D9 :                    ;;; @clobber HL
(1)    11D9 :                    cmpsi2:
(1)    11D9 : E4 4A                      ld      HL, (IX)
(1)    11DB : E5 77                      cp      HL, (IY)
(1)    11DD : 1E                         ret
(1)    11DE :
(1)    11DE :                    ;;; Unsigned multiplication: result = multiplicand * multiplier
(1)    11DE :                    ;;; @param BC: multiplicand
(1)    11DE :                    ;;; @param DE: multiplier
(1)    11DE :                    ;;; @return HL: result
(1)    11DE :                    ;;; @clobber BC DE HL A
(1)    11DE :                    umul16:
(1)    11DE : 3A 00 00                   ld      HL, 0           ; result=0
(1)    11E1 : C8 0C                      jr      umul16_check
(1)    11E3 :                    umul16_loop:
(1)    11E3 : FA A7                      srl     D
(1)    11E5 : FB A3                      rr      E               ; multiplier >>= 1
(1)    11E7 : CF 02                      jr      nc, umul16_next ; if lsb(multiplier) == 0
(1)    11E9 : F8 70                      add     HL, BC          ; result += multiplicand
(1)    11EB :                    umul16_next:
(1)    11EB : F9 A6                      sll     C
(1)    11ED : F8 A2                      rl      B               ; multiplicand <<= 1
(1)    11EF :                    umul16_check:
(1)    11EF : 22                         ld      A, D
(1)    11F0 : FB 66                      or      A, E
(1)    11F2 : CE EF                      jr      nz, umul16_loop ; while multiplier != 0
(1)    11F4 :                    umul16_end:
(1)    11F4 : 1E                         ret
(1)    11F5 :
(1)    11F5 :                    ;;; Unsigned multiplication: multiplicand *= multiplier
(1)    11F5 :                    ;;; @param @IX: multiplicand
(1)    11F5 :                    ;;; @param @IY: multiplier
(1)    11F5 :                    ;;; @clobber HL A
(1)    11F5 :                    umulsi2:
(1)    11F5 : 50                         push    BC
(1)    11F6 : 51                         push    DE
(1)    11F7 : E4 48                      ld      BC, (IX)        ; BC=multiplicand
(1)    11F9 : E5 49                      ld      DE, (IY)        ; DE=multiplier
(1)    11FB : 1C DE 11                   call    umul16          ; HL=multiplicand * multiplier
(1)    11FE : EC 42                      ld      (IX), HL
(1)    1200 : 59                         pop     DE
(1)    1201 : 58                         pop     BC
(1)    1202 : 1E                         ret
(1)    1203 :
(1)    1203 :                    ;;; Signed multiplication: multiplicand *= multiplier
(1)    1203 :                    ;;; @param @IX: multiplicand
(1)    1203 :                    ;;; @param @IY: multiplier
(1)    1203 :                    ;;; @clobber HL A
(1)    1203 :                    mulsi2:
(1)    1203 : 50                         push    BC
(1)    1204 : 51                         push    DE
(1)    1205 : E4 4A                      ld      HL, (IX)        ; HL=multiplicand
(1)    1207 : 24                         ld      A, H            ; A=high(multiplicand)
(1)    1208 : FC AF                      bit     7, H
(1)    120A : C6 04                      jr      Z, mulsi2_abs_muliplicand
(1)    120C : 7D FF FF                   xor     HL, 0FFFFH
(1)    120F : 92                         inc     HL              ; multiplicand = -multiplicand
(1)    1210 :                    mulsi2_abs_muliplicand:
(1)    1210 : 48                         ld      BC, HL          ; BC=abs(multiplicand)
(1)    1211 : E5 4A                      ld      HL, (IY)        ; HL=multiplier
(1)    1213 : FC 65                      xor     A, H            ; A=high(multiplicand^multiplier)
(1)    1215 : FC AF                      bit     7, H
(1)    1217 : C6 04                      jr      Z, mulsi2_multiply
(1)    1219 : 7D FF FF                   xor     HL, 0FFFFH
(1)    121C : 92                         inc     HL              ; multiplier = -multiplier
(1)    121D :                    mulsi2_multiply:
(1)    121D : 49                         ld      DE, HL          ; DE=abs(multiplyer)
(1)    121E : 56                         push    AF              ; save sign
(1)    121F : 1C DE 11                   call    umul16          ; HL = multiplicand * multiplier
(1)    1222 : 5E                         pop     AF              ; A=sign
(1)    1223 : FE AF                      bit     7, A
(1)    1225 : C6 04                      jr      Z, mulsi2_return
(1)    1227 : 7D FF FF                   xor     HL, 0FFFFH
(1)    122A : 92                         inc     HL              ; result = -result
(1)    122B :                    mulsi2_return:
(1)    122B : EC 42                      ld      (IX), HL
(1)    122D : 59                         pop     DE
(1)    122E : 58                         pop     BC
(1)    122F : 1E                         ret
(1)    1230 :
(1)    1230 :                    ;;; Unsigned division: divident / divisor = quotient ... reminder
(1)    1230 :                    ;;; @praram BC: divident
(1)    1230 :                    ;;; @praram DE: divisor
(1)    1230 :                    ;;; @return HL: reminder
(1)    1230 :                    ;;; @return BC: quotient
(1)    1230 :                    ;;; @clobber BC DE HL A
(1)    1230 :                    udiv16:
(1)    1230 : 22                         ld      A, D
(1)    1231 : FB 66                      or      A, E
(1)    1233 : FE D6                      ret     Z               ; divide by zero
(1)    1235 : 36 01                      ld      A, 1            ; A=bits
(1)    1237 : C8 05                      jr      udiv16_prep
(1)    1239 :                    udiv16_prep_loop:
(1)    1239 : FB A6                      sll     E
(1)    123B : FA A2                      rl      D               ; divisor <<= 1
(1)    123D : 86                         inc     A               ; ++bits
(1)    123E :                    udiv16_prep:                    ; while msb(divisor) == 0
(1)    123E : FA AF                      bit     7, D
(1)    1240 : C6 F7                      jr      Z, udiv16_prep_loop
(1)    1242 : 40                         ld      HL, BC          ; HL=divident
(1)    1243 : 38 00 00                   ld      BC, 0           ; BC=quotient
(1)    1246 : C8 08                      jr      udiv16_enter_loop
(1)    1248 :                    udiv16_loop:
(1)    1248 : FA A7                      srl     D
(1)    124A : FB A3                      rr      E               ; divisor >>= 1
(1)    124C : F9 A6                      sll     C
(1)    124E : F8 A2                      rl      B               ; quotient <<= 1
(1)    1250 :                    udiv16_enter_loop:
(1)    1250 : F9 72                      sub     HL, DE          ; divident -= divisor
(1)    1252 : C7 05                      jr      ULT, udiv16_readd ; if divident < 0
(1)    1254 : 81                         inc     C                 ; quotient |= 1
(1)    1255 : 8E                         dec     A
(1)    1256 : CE F0                      jr      NZ, udiv16_loop ; while bits != 0
(1)    1258 : 1E                         ret
(1)    1259 :                    udiv16_readd:
(1)    1259 : F9 70                      add     HL, DE          ; divident += divisor
(1)    125B : 8E                         dec     A               ; --bits
(1)    125C : CE EA                      jr      NZ, udiv16_loop ; while bits != 0
(1)    125E : 1E                         ret
(1)    125F :
(1)    125F :                    ;;; Unsigned division: dividend /= divisor
(1)    125F :                    ;;; @praram @IX: dividend
(1)    125F :                    ;;; @praram @IY: divisor
(1)    125F :                    ;;; @clobber HL A
(1)    125F :                    udivsi2:
(1)    125F : 50                         push    BC
(1)    1260 : 51                         push    DE
(1)    1261 : E4 48                      ld      BC, (IX)
(1)    1263 : E5 49                      ld      DE, (IY)
(1)    1265 : 1C 30 12                   call    udiv16
(1)    1268 : EC 40                      ld      (IX), BC
(1)    126A : 59                         pop     DE
(1)    126B : 58                         pop     BC
(1)    126C : 1E                         ret
(1)    126D :
(1)    126D :                    ;;; Signed division: divident *= divisor
(1)    126D :                    ;;; @param @IX: divident
(1)    126D :                    ;;; @param @IY: divisor
(1)    126D :                    ;;; @clobber HL A
(1)    126D :                    divsi2:
(1)    126D : 50                         push    BC
(1)    126E : 51                         push    DE
(1)    126F : E4 4A                      ld      HL, (IX)        ; HL=divident
(1)    1271 : 24                         ld      A, H            ; A=high(divident)
(1)    1272 : FC AF                      bit     7, H
(1)    1274 : C6 04                      jr      Z, divsi2_abs_divident
(1)    1276 : 7D FF FF                   xor     HL, 0FFFFH
(1)    1279 : 92                         inc     HL              ; divident = -divident
(1)    127A :                    divsi2_abs_divident:
(1)    127A : 48                         ld      BC, HL          ; BC=abs(divident)
(1)    127B : E5 4A                      ld      HL, (IY)        ; HL=divisor
(1)    127D : FC 65                      xor     A, H            ; A=high(divident^divisor)
(1)    127F : FC AF                      bit     7, H
(1)    1281 : C6 04                      jr      Z, divsi2_divide
(1)    1283 : 7D FF FF                   xor     HL, 0FFFFH
(1)    1286 : 92                         inc     HL              ; divisor = -divisor
(1)    1287 :                    divsi2_divide:
(1)    1287 : 49                         ld      DE, HL          ; DE=abs(dvisor)
(1)    1288 : 56                         push    AF              ; save sign
(1)    1289 : 1C 30 12                   call    udiv16          ; BC = divident / divisor
(1)    128C : 5E                         pop     AF              ; A=sign
(1)    128D : 40                         ld      HL, BC          ; HL=quotient
(1)    128E : FE AF                      bit     7, A
(1)    1290 : C6 04                      jr      Z, divsi2_return
(1)    1292 : 7D FF FF                   xor     HL, 0FFFFH
(1)    1295 : 92                         inc     HL              ; quotient=-quotient
(1)    1296 :                    divsi2_return:
(1)    1296 : EC 42                      ld      (IX), HL
(1)    1298 : 59                         pop     DE
(1)    1299 : 58                         pop     BC
(1)    129A : 1E                         ret
(1)    129B :
(1)    129B :                    ;;; Local Variables:
(1)    129B :                    ;;; mode: asm
(1)    129B :                    ;;; End:
(1)    129B :                    ;;; vim: set ft=asm et ts=4 sw=4:
       129B :
       129B :                            end
