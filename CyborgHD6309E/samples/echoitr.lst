   0:                                CPU   6809
   0:                                INCLUDE               "mc6809.inc"
   0:                ;;; -*- mode: asm; mode: flyspell-prog; -*-
   0:
   0:                ;;; Condition Code Register (CC)
   0: =$1            CC_CARRY        EQU   %00000001       ; set to 1 if carry occurred
   0: =$2            CC_OVERFLOW     EQU   %00000010       ; set to 1 if overflow occurred
   0: =$4            CC_ZERO         EQU   %00000100       ; set to 1 if result is zero
   0: =$8            CC_NEGATIVE     EQU   %00001000       ; set to 1 if result is negative
   0: =$10           CC_IRQ          EQU   %00010000       ; if 1, IRQ is masked
   0: =$20           CC_HALF_CARRY   EQU   %00100000       ; if 1, decimal carry from least digit occurred
   0: =$40           CC_FIRQ         EQU   %01000000       ; if 1, FIRQ is masked
   0: =$80           CC_ENTIRE       EQU   %10000000       ; set to 1 if entire registers are pushed
   0:
   0:                ;;; Vector
   0: =$FFF0         VEC_RESERVED:   EQU   $FFF0           ; $FFF0: Reserved
   0: =$FFF2         VEC_SWI3:       EQU   $FFF2           ; $FFF2: Software Interrupt 3
   0: =$FFF4         VEC_SWI2:       EQU   $FFF4           ; $FFF4: Software Interrupt 2
   0: =$FFF6         VEC_FIRQ:       EQU   $FFF6           ; $FFF6: Fast Interrupt Request
   0: =$FFF8         VEC_IRQ:        EQU   $FFF8           ; $FFF8: Interrupt Request
   0: =$FFFA         VEC_SWI:        EQU   $FFFA           ; $FFFA: Software Interrupt
   0: =$FFFC         VEC_NMI:        EQU   $FFFC           ; $FFFC: Non Maskable Interrupt
   0: =$FFFE         VEC_RESET:      EQU   $FFFE           ; $FFFE: Reset
   0:
   0:                ;;; MC6850 Asynchronous Communication Interface Adapter
   0: =$DF00         ACIA:           EQU   $DF00
   0:                                INCLUDE               "mc6850.inc"
   0:                ;;; -*- mode: asm; mode: flyspell-prog; -*-
   0:
   0:                ;;; MC6850
   0:                ;;; Asynchronous Communication Interface Adapter
   0:
   0:                ;;; Control register
   0: =$DF00         ACIA_control:   EQU   ACIA+0
   0:                ;; Counter Divider Select Bits
   0: =$3            CDS_gm:         EQU   %11             ; Group mask
   0: =$0            CDS_DIV1_gc:    EQU   %00000000       ; /1
   0: =$1            CDS_DIV16_gc:   EQU   %00000001       ; /16
   0: =$2            CDS_DIV64_gc:   EQU   %00000010       ; /64
   0: =$3            CDS_RESET_gc:   EQU   %00000011       ; Master Reset
   0:                ;; Word Select Bits
   0: =$1C           WSB_gm:         EQU   %00011100       ; Group mask
   0: =$0            WSB_7E2_gc:     EQU   %00000000       ; 7 Bits + Even Parity + 2 Stop Bits
   0: =$4            WSB_7O2_gc:     EQU   %00000100       ; 7 bits + Odd Parity  + 2 Stop Bits
   0: =$8            WSB_7E1_gc:     EQU   %00001000       ; 7 bits + Even Parity + 1 Stop Bits
   0: =$C            WSB_7O1_gc:     EQU   %00001100       ; 7 bits + Odd Parity  + 1 Stop Bits
   0: =$10           WSB_8N2_gc:     EQU   %00010000       ; 8 bits + No Parity   + 2 Stop Bits
   0: =$14           WSB_8N1_gc:     EQU   %00010100       ; 8 bits + No Parity   + 1 Stop Bits
   0: =$18           WSB_8E1_gc:     EQU   %00011000       ; 8 bits + Even Parity + 1 Stop Bits
   0: =$1C           WSB_8O1_gc:     EQU   %00011100       ; 8 bits + Odd Parity  + 1 Stop Bits
   0:                ;; Transmit Control Bits
   0: =$60           TCB_gm:         EQU   %01100000       ; Group mask
   0: =$0            TCB_DI_gc:      EQU   %00000000       ; RTS=Low,  Tx Interrupt Disabled
   0: =$20           TCB_EI_gc:      EQU   %00100000       ; RTS=Low,  Tx Interrupt Enabled
   0: =$40           TCB_RTS_gc:     EQU   %01000000       ; RTS=High, Tx Interrupt Disabled
   0: =$60           TCB_BREAK_gc:   EQU   %01100000       ; RTS=Low,  Tx Interrupt Disabled
   0:                ; Transmit Break Level
   0: =$80           RIEB_bm:        EQU   %10000000       ; Receive Interrupt Enable Bit mask
   0:
   0:                ;;; Status register
   0: =$DF00         ACIA_status:    EQU   ACIA+0
   0: =$1            RDRF_bm:        EQU   %00000001       ; Receive Data Register Full
   0: =$2            TDRE_bm:        EQU   %00000010       ; Transmit Data Register Empty
   0: =$4            DCDF_bm:        EQU   %00000100       ; Data Carrier Detect Flag
   0: =$8            CTSF_bm:        EQU   %00001000       ; Clear To Send Flag
   0: =$10           FERR_bm:        EQU   %00010000       ; Frame Error Flag
   0: =$20           OVRN_bm:        EQU   %00100000       ; Receiver Overrun Flag
   0: =$40           PERR_bm:        EQU   %01000000       ; Parity Error Flag
   0: =$80           IRQF_bm:        EQU   %10000000       ; Interrupt Request Flag
   0:
   0:                ;;; Data register
   0: =$DF01         ACIA_data:      EQU   ACIA+1          ; Data register
   0:
2000:                                ORG   $2000
2000:
2000: =$80           rx_queue_size:  EQU   128
2000:                rx_queue:       RMB   rx_queue_size
2080: =$80           tx_queue_size:  EQU   128
2080:                tx_queue:       RMB   tx_queue_size
2100: =$94           RX_INT_TX_NO:   EQU   WSB_8N1_gc|RIEB_bm
2100: =$B4           RX_INT_TX_INT:  EQU   WSB_8N1_gc|RIEB_bm|TCB_EI_gc
2100:                tx_int_control: RMB   1
2101:
1000:                                ORG   $1000
1000: =$1000         stack:          EQU   *
1000:
1000:                                ORG   $1000
1000:                initialize:
1000: 10 CE 10 00                    LDS   #stack
1004: 8E 20 00                       LDX   #rx_queue
1007: C6 80                          LDB   #rx_queue_size
1009: 17 00 AC                       LBSR  queue_init
100C: 8E 20 80                       LDX   #tx_queue
100F: C6 80                          LDB   #tx_queue_size
1011: 17 00 A4                       LBSR  queue_init
1014:                ;; initialize ACIA
1014: 86 03                          LDA   #CDS_RESET_gc   ; master reset
1016: B7 DF 00                       STA   ACIA_control
1019: 86 94                          LDA   #RX_INT_TX_NO
101B: B7 DF 00                       STA   ACIA_control
101E: 7F 21 00                       CLR   tx_int_control  ; disabl Tx interrupt
1021: 1C EF                          ANDCC #~CC_IRQ        ; Clear IRQ mask
1023:
1023:                receive_loop:
1023: 17 00 68                       LBSR  getchar
1026: 24 FB                          BCC   receive_loop
1028:                echo_back:
1028: 1F 89                          TFR   a,b
102A: 17 00 72                       LBSR  putchar         ; echo
102D: 86 20                          LDA   #$20            ; space
102F: 17 00 6D                       LBSR  putchar
1032: 8D 14                          BSR   put_hex8        ; print in hex
1034: 86 20                          LDA   #$20
1036: 17 00 66                       LBSR  putchar
1039: 8D 31                          BSR   put_bin8        ; print in binary
103B: 17 00 02                       LBSR  newline
103E: 20 E3                          BRA   receive_loop
1040:
1040:                ;;; Put newline
1040:                ;;; @clobber A
1040:                newline:
1040: 86 0D                          LDA   #$0d
1042: 8D 5B                          BSR   putchar
1044: 86 0A                          LDA   #$0a
1046: 20 57                          BRA   putchar
1048:
1048:                ;;; Print uint8_t in hex
1048:                ;;; @param B uint8_t value to be printed in hex.
1048:                ;;; @clobber A
1048:                put_hex8:
1048: 86 30                          LDA   #'0'
104A: 17 00 52                       LBSR  putchar
104D: 86 78                          LDA   #'x'
104F: 17 00 4D                       LBSR  putchar
1052: 1F 98                          TFR   b,a
1054: 44                             LSRA
1055: 44                             LSRA
1056: 44                             LSRA
1057: 44                             LSRA
1058: 8D 02                          BSR   put_hex4
105A: 1F 98                          TFR   b,a
105C:                put_hex4:
105C: 84 0F                          ANDA  #$0f
105E: 81 0A                          CMPA  #10
1060: 25 05                          BLO   put_hex8_dec
1062: 8B 37                          ADDA  #'A'-10
1064: 16 00 38                       LBRA  putchar
1067:                put_hex8_dec:
1067: 8B 30                          ADDA  #'0'
1069: 16 00 33                       LBRA  putchar
106C:
106C:                ;;; Print uint8_t in binary
106C:                ;;; @param B uint8_t value to be printed in binary.
106C:                ;;; @clobber A
106C:                put_bin8:
106C: 34 04                          PSHS  b
106E: 86 30                          LDA   #'0'
1070: 17 00 2C                       LBSR  putchar
1073: 86 62                          LDA   #'b'
1075: 17 00 27                       LBSR  putchar
1078: 8D 05                          BSR   put_bin4
107A: 58                             LSLB
107B: 8D 02                          BSR   put_bin4
107D: 35 84                          PULS  b,pc
107F:                put_bin4:
107F: 8D 01                          BSR   put_bin2
1081: 58                             LSLB
1082:                put_bin2:
1082: 8D 01                          BSR   put_bin1
1084: 58                             LSLB
1085:                put_bin1:
1085: 86 30                          LDA   #'0'
1087: 5D                             TSTB                  ; chech MSB
1088: 2A 01                          BPL   put_bin0        ; MSB=0
108A: 4C                             INCA                  ; MSB=1
108B:                put_bin0:
108B: 16 00 11                       LBRA  putchar
108E:
108E:                ;;; Get character
108E:                ;;; @return A
108E:                ;;; @return CC.C 0 if no character
108E:                getchar:
108E: 1A 01                          ORCC  #CC_CARRY       ; set carry
1090: 34 11                          PSHS  x,cc
1092: 1A 10                          ORCC  #CC_IRQ         ; disable IRQ
1094: 8E 20 00                       LDX   #rx_queue
1097: 8D 50                          BSR   queue_remove
1099: 25 02                          BCS   getchar_end
109B: 6A E4                          DEC   ,s              ; clear carry
109D:                getchar_end:
109D: 35 91                          PULS  cc,x,pc
109F:
109F:                ;;; Put character
109F:                ;;; @param A
109F:                putchar:
109F: 34 13                          PSHS  x,a,cc
10A1: 1A 10                          ORCC  #CC_IRQ         ; disable IRQ
10A3: 8E 20 80                       LDX   #tx_queue
10A6: 17 00 20                       LBSR  queue_add
10A9: 7D 21 00                       TST   tx_int_control
10AC: 26 08                          BNE   putchar_end
10AE: 86 B4                          LDA   #RX_INT_TX_INT  ; enable Tx interrupt
10B0: B7 21 00                       STA   tx_int_control
10B3: B7 DF 00                       STA   ACIA_control
10B6:                putchar_end:
10B6: 35 93                          PULS  cc,a,x,pc
10B8:
10B8:                                INCLUDE               "queue.inc"
10B8:                ;;; -*- mode: asm; mode: flying-spell; -*-
10B8:
10B8:                ;;; [queue] queue structure
10B8: =$0            queue_len:      EQU   0               ; queue length
10B8: =$1            queue_size:     EQU   1               ; buffer size
10B8: =$2            queue_put:      EQU   2               ; queue put index
10B8: =$3            queue_get:      EQU   3               ; queue get index
10B8: =$4            queue_buf:      EQU   4               ; buffer start offset
10B8:
10B8:                ;;; [queue] Initialize queue
10B8:                ;;; @param X queue work space pointer
10B8:                ;;; @param B queue work space size
10B8:                ;;; @clobber B
10B8:                queue_init:
10B8: 34 16                          PSHS  x,d
10BA: 4F                             CLRA
10BB:                queue_init_loop:
10BB: 6F 80                          CLR   ,x+
10BD: 83 00 01                       SUBD  #1
10C0: 26 F9                          BNE   queue_init_loop
10C2: 35 16                          PULS  d,x
10C4: C0 04                          SUBB  #queue_buf
10C6: E7 01                          STB   queue_size,x
10C8: 39                             RTS
10C9:
10C9:                ;;; [queue] Add an element to queue
10C9:                ;;; @param X queue work space pointer
10C9:                ;;; @param A an element
10C9:                ;;; @return CC.C 0 if queue is full
10C9:                queue_add:
10C9: 34 04                          PSHS  b
10CB: E6 84                          LDB   queue_len,x
10CD: E1 01                          CMPB  queue_size,x
10CF: 24 16                          BHS   queue_add_return    ;carry is cleared
10D1: E6 02                          LDB   queue_put,x     ; 8 bits offset
10D3: 34 10                          PSHS  x
10D5: 3A                             ABX                   ; X+=B
10D6: A7 04                          STA   queue_buf,x     ; store an element
10D8: 35 10                          PULS  x
10DA: 6C 84                          INC   queue_len,x
10DC: 5C                             INCB
10DD: E7 02                          STB   queue_put,x
10DF: E1 01                          CMPB  queue_size,x
10E1: 25 04                          BLO   queue_add_return    ; carry is set
10E3: 6F 02                          CLR   queue_put,x
10E5: 1A 01                          ORCC  #1              ; set carry
10E7:                queue_add_return:
10E7: 35 84                          PULS  b,pc
10E9:
10E9:                ;;; [queue] Remove an element from queue
10E9:                ;;; @param X queue work space pointer
10E9:                ;;; @return A an element
10E9:                ;;; @return CC.C 0 if queue is empty
10E9:                queue_remove:
10E9: 6D 84                          TST   queue_len,x
10EB: 26 03                          BNE   queue_remove_elem
10ED: 1C FE                          ANDCC #~1             ; clear carry
10EF: 39                             RTS
10F0:                queue_remove_elem:
10F0: 34 04                          PSHS  b
10F2: E6 03                          LDB   queue_get,x     ; 8 bits offset
10F4: 34 10                          PSHS  x
10F6: 3A                             ABX                   ; X+=B
10F7: A6 04                          LDA   queue_buf,x
10F9: 35 10                          PULS  x
10FB: 6A 84                          DEC   queue_len,x
10FD: 5C                             INCB
10FE: E7 03                          STB   queue_get,x
1100: E1 01                          CMPB  queue_size,x
1102: 25 04                          BLO   queue_remove_return ; carry is set
1104: 6F 03                          CLR   queue_get,x
1106: 1A 01                          ORCC  #1              ; set carry
1108:                queue_remove_return:
1108: 35 84                          PULS  b,pc
110A:
110A:
110A:                isr_irq:
110A: F6 DF 00                       LDB   ACIA_status
110D: C5 80                          BITB  #IRQF_bm
110F: 27 2B                          BEQ   isr_irq_return
1111:                isr_irq_receive:
1111: C5 01                          BITB  #RDRF_bm
1113: 27 09                          BEQ   isr_irq_recv_end
1115: B6 DF 01                       LDA   ACIA_data       ; receive character
1118: 8E 20 00                       LDX   #rx_queue
111B: 17 FF AB                       LBSR  queue_add
111E:                isr_irq_recv_end:
111E:                isr_irq_send:
111E: C5 02                          BITB  #TDRE_bm
1120: 27 1A                          BEQ   isr_irq_send_end
1122: 8E 20 80                       LDX   #tx_queue
1125: 17 FF C1                       LBSR  queue_remove
1128: 24 05                          BCC   isr_irq_send_empty
112A: B7 DF 01                       STA   ACIA_data       ; send character
112D: 20 0D                          BRA   isr_irq_send_end
112F:                isr_irq_send_empty:
112F: 7D 21 00                       TST   tx_int_control
1132: 27 08                          BEQ   isr_irq_send_end
1134: 86 94                          LDA   #RX_INT_TX_NO
1136: B7 DF 00                       STA   ACIA_control    ; disable Tx interrupt
1139: 7F 21 00                       CLR   tx_int_control
113C:                isr_irq_send_end:
113C:                isr_irq_return:
113C: 3B                             RTI
113D:
FFF8:                                ORG   $FFF8
FFF8: 11 0A                          FDB   isr_irq
FFFA:
FFFE:                                ORG   $FFFE
FFFE: 10 00                          FDB   initialize
