   0:                          CPU  ins8070
   0:                          INCLUDE              "ins8070.inc"
   0:          ;;; -*- mode: asm; mode: flyspell-prog; -*-
   0:
   0:          ;;; INS8070
   0:          ;;; Status Register
   0: =$80     S_CY:           EQU  0x80            ; Carry bit
   0: =$80     S_L:            EQU  0x80            ; Link bit
   0: =$40     S_OV:           EQU  0x40            ; Overflow bit
   0: =$20     S_SB:           EQU  0x20            ; Sense B bit
   0: =$10     S_SA:           EQU  0x10            ; Sense A bit
   0: =$8      S_F3:           EQU  0x08            ; Flag 3 bit
   0: =$4      S_F2:           EQU  0x04            ; Flag 2 bit
   0: =$2      S_F1:           EQU  0x02            ; Flag 1 bit
   0: =$1      S_IE:           EQU  0x01            ; Interrupt Enable bit
   0:
   0:          ;;; Transfer locations
   0: =$1      ORG_RESTART:    EQU  0x0001          ; Restart transfer location
   0: =$4      ORG_INTA:       EQU  0x0004          ; Interrupt A transfer location
   0: =$7      ORG_INTB:       EQU  0x0007          ; Interrupt B transfer location
   0: =$A      ORG_END:        EQU  0x000A
   0:
   0:          ;;; Call vectors
   0: =$20     VEC_CALL0:      EQU  0x0020          ; Call 0 vector
   0: =$22     VEC_CALL1:      EQU  0x0022          ; Call 0 vector
   0: =$24     VEC_CALL2:      EQU  0x0024          ; Call 0 vector
   0: =$26     VEC_CALL3:      EQU  0x0026          ; Call 0 vector
   0: =$28     VEC_CALL4:      EQU  0x0028          ; Call 0 vector
   0: =$2A     VEC_CALL5:      EQU  0x002A          ; Call 0 vector
   0: =$2C     VEC_CALL6:      EQU  0x002C          ; Call 0 vector
   0: =$2E     VEC_CALL7:      EQU  0x002E          ; Call 0 vector
   0: =$30     VEC_CALL8:      EQU  0x0030          ; Call 0 vector
   0: =$32     VEC_CALL9:      EQU  0x0032          ; Call 0 vector
   0: =$34     VEC_CALL10:     EQU  0x0034          ; Call 0 vector
   0: =$36     VEC_CALL11:     EQU  0x0036          ; Call 0 vector
   0: =$38     VEC_CALL12:     EQU  0x0038          ; Call 0 vector
   0: =$3A     VEC_CALL13:     EQU  0x003A          ; Call 0 vector
   0: =$3C     VEC_CALL14:     EQU  0x003C          ; Call 0 vector
   0: =$3E     VEC_CALL15:     EQU  0x003E          ; Call 0 vector
   0: =$40     VEC_END:        EQU  0x0040
   0:
   0:          ;;; MC6850 Asynchronous Communication Interface Adapter
   0: =$DF00   ACIA:           EQU  0xDF00
   0:                          INCLUDE              "mc6850.inc"
   0:          ;;; -*- mode: asm; mode: flyspell-prog; -*-
   0:
   0:          ;;; MC6850
   0:          ;;; Asynchronous Communication Interface Adapter
   0:
   0:          ;;; Control register
   0: =$DF00   ACIA_control:   EQU  ACIA+0
   0:          ;; Counter Divider Select Bits
   0: =$3      CDS_gm:         EQU  0b11            ; Group mask
   0: =$0      CDS_DIV1_gc:    EQU  0b00000000      ; /1
   0: =$1      CDS_DIV16_gc:   EQU  0b00000001      ; /16
   0: =$2      CDS_DIV64_gc:   EQU  0b00000010      ; /64
   0: =$3      CDS_RESET_gc:   EQU  0b00000011      ; Master Reset
   0:          ;; Word Select Bits
   0: =$1C     WSB_gm:         EQU  0b00011100      ; Group mask
   0: =$0      WSB_7E2_gc:     EQU  0b00000000      ; 7 Bits + Even Parity + 2 Stop Bits
   0: =$4      WSB_7O2_gc:     EQU  0b00000100      ; 7 bits + Odd Parity  + 2 Stop Bits
   0: =$8      WSB_7E1_gc:     EQU  0b00001000      ; 7 bits + Even Parity + 1 Stop Bits
   0: =$C      WSB_7O1_gc:     EQU  0b00001100      ; 7 bits + Odd Parity  + 1 Stop Bits
   0: =$10     WSB_8N2_gc:     EQU  0b00010000      ; 8 bits + No Parity   + 2 Stop Bits
   0: =$14     WSB_8N1_gc:     EQU  0b00010100      ; 8 bits + No Parity   + 1 Stop Bits
   0: =$18     WSB_8E1_gc:     EQU  0b00011000      ; 8 bits + Even Parity + 1 Stop Bits
   0: =$1C     WSB_8O1_gc:     EQU  0b00011100      ; 8 bits + Odd Parity  + 1 Stop Bits
   0:          ;; Transmit Control Bits
   0: =$60     TCB_gm:         EQU  0b01100000      ; Group mask
   0: =$0      TCB_DI_gc:      EQU  0b00000000      ; RTS=Low,  Tx Interrupt Disabled
   0: =$20     TCB_EI_gc:      EQU  0b00100000      ; RTS=Low,  Tx Interrupt Enabled
   0: =$40     TCB_RTS_gc:     EQU  0b01000000      ; RTS=High, Tx Interrupt Disabled
   0: =$60     TCB_BREAK_gc:   EQU  0b01100000      ; RTS=Low,  Tx Interrupt Disabled
   0:          ; Transmit Break Level
   0: =$80     RIEB_bm:        EQU  0b10000000      ; Receive Interrupt Enable Bit mask
   0:
   0:          ;;; Status register
   0: =$DF00   ACIA_status:    EQU  ACIA+0
   0: =$1      RDRF_bm:        EQU  0b00000001      ; Receive Data Register Full
   0: =$2      TDRE_bm:        EQU  0b00000010      ; Transmit Data Register Empty
   0: =$4      DCDF_bm:        EQU  0b00000100      ; Data Carrier Detect Flag
   0: =$8      CTSF_bm:        EQU  0b00001000      ; Clear To Send Flag
   0: =$10     FERR_bm:        EQU  0b00010000      ; Frame Error Flag
   0: =$20     OVRN_bm:        EQU  0b00100000      ; Receiver Overrun Flag
   0: =$40     PERR_bm:        EQU  0b01000000      ; Parity Error Flag
   0: =$80     IRQF_bm:        EQU  0b10000000      ; Interrupt Request Flag
   0:
   0:          ;;; Data register
   0: =$DF01   ACIA_data:      EQU  ACIA+1          ; Data register
   0: =$0      ACIA_C:         EQU  0               ; ACIA control offset
   0: =$0      ACIA_S:         EQU  0               ; ACIA status offset
   0: =$1      ACIA_D:         EQU  1               ; ACIA data register offset
   0:
   0: =$10     rx_queue_size:  EQU  16
   0: =$30     tx_queue_size:  EQU  48
   0: =$94     RX_INT_TX_NO:   EQU  WSB_8N1_gc|RIEB_bm
   0: =$B4     RX_INT_TX_INT:  EQU  WSB_8N1_gc|RIEB_bm|TCB_EI_gc
   0:
2000:                          ORG  0x2000
2000:          rx_queue:
2000:                          DS   rx_queue_size
2010:          tx_queue:
2010:                          DS   tx_queue_size
2040:
FF00:                          ORG  0xFF00
FF00:          tx_int_control:
FF00:                          DS   1
FF01:
1000:                          ORG  0x1000
1000:          stack:
1000:          initialize:
1000: 25 00 10                 LD   sp, =stack
1003:          ;; initialize queues
1003: 26 00 20                 LD   p2, =rx_queue
1006: C4 10                    LD   a, =rx_queue_size
1008: 20 D1 10                 JSR  queue_init
100B: 26 10 20                 LD   p2, =tx_queue
100E: C4 30                    LD   a, =tx_queue_size
1010: 20 D1 10                 JSR  queue_init
1013:
1013:          ;; initialize ACIA
1013: 26 00 DF                 LD   p2, =ACIA
1016: C4 03                    LD   a, =CDS_RESET_gc    ; master reset
1018: CA 00                    ST   a, ACIA_C, p2
101A: C4 94                    LD   a, =RX_INT_TX_NO
101C: CA 00                    ST   a, ACIA_C, p2
101E: C4 00                    LD   a, =0
1020: CD 00                    ST   a, tx_int_control   ; disable Tx interrupt
1022: 3B 01                    OR   s, =S_IE        ; enable IRQ
1024:
1024:          loop:
1024: 20 A4 10                 JSR  getchar
1027: 6C FB                    BZ   loop
1029: 40                       LD   a, e
102A: 20 AF 10                 JSR  putchar         ; echo
102D: C4 20                    LD   a, =' '         ; space
102F: 20 AF 10                 JSR  putchar
1032: 40                       LD   a, e
1033: 20 4D 10                 JSR  put_hex8        ; print in hex
1036: C4 20                    LD   a, =' '         ; space
1038: 20 AF 10                 JSR  putchar
103B: 40                       LD   a, e
103C: 20 78 10                 JSR  put_bin8        ; print in binary
103F: 20 43 10                 JSR  newline
1042: 74 E0                    BRA  loop
1044:
1044:          ;;; Put newline
1044:          ;;; @clobber A
1044:          newline:
1044: C4 0D                    LD   a, =0x0D
1046: 20 AF 10                 JSR  putchar
1049: C4 0A                    LD   a, =0x0A
104B: 24 AF 10                 JMP  putchar
104E:
104E:          ;;; Print uint8_t in hex
104E:          ;;; @param A uint8_t value to be printed in hex.
104E:          put_hex8:
104E: 08                       PUSH ea
104F: C4 30                    LD   a, ='0'
1051: 20 AF 10                 JSR  putchar
1054: C4 78                    LD   a, ='x'
1056: 20 AF 10                 JSR  putchar
1059: C1 00                    LD   a, 0, sp
105B: 3C                       SR   a
105C: 3C                       SR   a
105D: 3C                       SR   a
105E: 3C                       SR   a
105F: 20 68 10                 JSR  put_hex4
1062: C1 00                    LD   a, 0, sp
1064: 20 68 10                 JSR  put_hex4
1067: 3A                       POP  ea
1068: 5C                       RET
1069:          put_hex4:
1069: D4 0F                    AND  a, =0x0f
106B: FC 0A                    SUB  a, =10
106D: 64 05                    BP   put_hex4_hex
106F: F4 3A                    ADD  a, ='0'+10
1071: 24 AF 10                 JMP  putchar
1074:          put_hex4_hex:
1074: F4 41                    ADD  a, ='A'
1076: 24 AF 10                 JMP  putchar
1079:
1079:          ;;; Print uint8_t in binary
1079:          ;;; @param A(save_a) uint8_t value to be printed in binary.
1079:          put_bin8:
1079: 08                       PUSH ea
107A: C4 30                    LD   a, ='0'
107C: 20 AF 10                 JSR  putchar
107F: C4 62                    LD   a, ='b'
1081: 20 AF 10                 JSR  putchar
1084: C1 00                    LD   a, 0, sp
1086: 48                       LD   e, a
1087: 20 8E 10                 JSR  put_bin4
108A: 20 8E 10                 JSR  put_bin4
108D: 3A                       POP  ea
108E: 5C                       RET
108F:          put_bin4:
108F: 20 91 10                 JSR  put_bin2
1092:          put_bin2:
1092: 20 94 10                 JSR  put_bin1
1095:          put_bin1:
1095: 40                       LD   a, e
1096: 70                       ADD  a, e
1097: 48                       LD   e, a            ; E<<=1
1098: 06                       LD   a, s
1099: 64 05                    BP   put_bin0        ; A:7=CY
109B: C4 31                    LD   a, ='1'
109D: 24 AF 10                 JMP  putchar
10A0:          put_bin0:
10A0: C4 30                    LD   a, ='0'
10A2: 24 AF 10                 JMP  putchar
10A5:
10A5:          ;;; Get character
10A5:          ;;; @clobber P2
10A5:          ;;; @return E char
10A5:          ;;; @return A 0 if no char received
10A5:          getchar:
10A5: 26 00 20                 LD   p2, =rx_queue
10A8: 39 FE                    AND  s, =~S_IE       ; disable IRQ
10AA: 20 16 11                 JSR  queue_remove
10AD: 3B 01                    OR   s, =S_IE        ; enable IRQ
10AF: 5C                       RET
10B0:
10B0:          ;;; Put character
10B0:          ;;; @param A char
10B0:          ;;; @clobber P2
10B0:          putchar:
10B0: 08                       PUSH ea
10B1: 48                       LD   e, a
10B2:          putchar_retry:
10B2: 40                       LD   a, e
10B3: 26 10 20                 LD   p2, =tx_queue
10B6: 39 FE                    AND  s, =~S_IE       ; disable IRQ
10B8: 20 F8 10                 JSR  queue_add
10BB: 3B 01                    OR   s, =S_IE        ; enable IRQ
10BD: 6C F3                    BZ   putchar_retry   ; queue is full
10BF: 39 FE                    AND  s, =~S_IE       ; disable IRQ
10C1: C5 00                    LD   a, tx_int_control
10C3: 7C 09                    BNZ  putchar_exit
10C5: 26 00 DF                 LD   p2, =ACIA
10C8: C4 B4                    LD   a, =RX_INT_TX_INT   ; enable Tx interrupt
10CA: CA 00                    ST   a, ACIA_C, p2
10CC: CD 00                    ST   a, tx_int_control
10CE:          putchar_exit:
10CE: 3A                       POP  ea
10CF: 3B 01                    OR   s, =S_IE        ; enable IRQ
10D1: 5C                       RET
10D2:
10D2:                          INCLUDE              "queue.inc"
10D2:          ;;; [queue] queue structure
10D2: =$0      queue_len:      EQU  0               ; queue length
10D2: =$1      queue_size:     EQU  1               ; buffer size
10D2: =$2      queue_put:      EQU  2               ; queue put index
10D2: =$3      queue_get:      EQU  3               ; queue get index
10D2: =$4      queue_buf:      EQU  4               ; buffer start offset
10D2:
10D2:          ;;; [queue] Initialize queue
10D2:          ;;; @param P2 queue work space pointer
10D2:          ;;; @param A queue work space size
10D2:          ;;; @clobber A
10D2:          queue_init:
10D2: 48                       LD   e, a
10D3: C4 00                    LD   a, =0
10D5: CA 00                    ST   a, queue_len, p2
10D7: CA 02                    ST   a, queue_put, p2
10D9: CA 03                    ST   a, queue_get, p2
10DB: 01                       XCH  a, e            ; E=0, A=space size
10DC: FC 04                    SUB  a, =queue_buf
10DE: CA 01                    ST   a, queue_size, p2
10E0: 0A                       PUSH a               ; 0,SP=counter
10E1: C6 04                    LD   a, @queue_buf, p2
10E3:          queue_init_loop:
10E3: 40                       LD   a, e            ; E=0
10E4: CE 01                    ST   a, @1, p2
10E6: 99 00                    DLD  a, 0, sp
10E8: 7C F9                    BNZ  queue_init_loop
10EA: 38                       POP  a               ; discard counter
10EB: 5C                       RET
10EC:
10EC:          ;;; [add_p2_a] Add A to P2
10EC:          ;;; @param P2
10EC:          ;;; @param A
10EC:          ;;; @return P3=P2+A
10EC:          add_p2_a:
10EC: 08                       PUSH ea              ; save EA
10ED: 01                       XCH  a, e
10EE: C4 00                    LD   a, =0
10F0: 01                       XCH  a, e
10F1: 08                       PUSH ea              ; 0:E
10F2: 32                       LD   ea, p2
10F3: B1 00                    ADD  ea, 0, sp       ; EA=P2+E
10F5: 47                       LD   p3, ea
10F6: 3A                       POP  ea
10F7: 3A                       POP  ea              ; restore EA
10F8: 5C                       RET
10F9:
10F9:          ;;; [queue] Add an element to queue
10F9:          ;;; @param P2 queue work space pointer
10F9:          ;;; @param A an element
10F9:          ;;; @return E an element
10F9:          ;;; @return A 0 if queue is full
10F9:          queue_add:
10F9: 57                       PUSH p3
10FA: 48                       LD   e, a            ; save element in E
10FB: C2 00                    LD   a, queue_len, p2
10FD: FA 01                    SUB  a, queue_size, p2
10FF: 6C 14                    BZ   queue_add_return    ; A=0
1101: C2 02                    LD   a, queue_put, p2    ; 8 bits offset
1103: 20 EB 10                 JSR  add_p2_a
1106: 40                       LD   a, e
1107: CB 04                    ST   a, queue_buf, p3    ; store an element
1109: 92 00                    ILD  a, queue_len, p2
110B: 92 02                    ILD  a, queue_put, p2
110D: FA 01                    SUB  a, queue_size, p2
110F: 7C 04                    BNZ  queue_add_return    ; A is not zero
1111: CA 02                    ST   a, queue_put, p2
1113: C4 01                    LD   a, =1           ; A is not zero
1115:          queue_add_return:
1115: 5F                       POP  p3
1116: 5C                       RET
1117:
1117:          ;;; [queue] Remove an element from queue
1117:          ;;; @param P2 queue work space pointer
1117:          ;;; @return E an element
1117:          ;;; @return A 0 if queue is empty
1117:          queue_remove:
1117: 57                       PUSH p3
1118: C2 00                    LD   a, queue_len, p2
111A: 6C 14                    BZ   queue_remove_return ; A is zero
111C:          queue_remove_elem
111C: C2 03                    LD   a, queue_get, p2    ; 8 bits offset
111E: 20 EB 10                 JSR  add_p2_a
1121: C3 04                    LD   a, queue_buf, p3    ; read an element
1123: 48                       LD   e, a
1124: 9A 00                    DLD  a, queue_len, p2
1126: 92 03                    ILD  a, queue_get, p2
1128: FA 01                    SUB  a, queue_size, p2
112A: 7C 04                    BNZ  queue_remove_return ; A is not zero
112C: CA 03                    ST   a, queue_get, p2    ; A is zero
112E: C4 01                    LD   a, =1           ; A is not zero
1130:          queue_remove_return:
1130: 5F                       POP  p3
1131: 5C                       RET
1132:
1132:          ;;; Local Variables:
1132:          ;;; mode: asm
1132:          ;;; End:
1132:          ;;; vim: set ft=asm et ts=4 sw=4:
1132:
1132:          isr_irq:
1132: 08                       PUSH ea
1133: 22 00 DF                 PLI  p2, =ACIA
1136: C2 00                    LD   a, ACIA_S, p2
1138: 48                       LD   e, a            ; save ACIA status in E
1139: D4 80                    AND  a, =IRQF_bm
113B: 6C 32                    BZ   isr_irq_exit
113D: 40                       LD   a, e
113E: D4 70                    AND  a, =FERR_bm|OVRN_bm|PERR_bm
1140: 6C 02                    BZ   isr_irq_receive
1142: C2 01                    LD   a, ACIA_D, p2   ; clear errors
1144:          isr_irq_receive:
1144: 40                       LD   a, e
1145: 0A                       PUSH a               ; save ACIA status
1146: D4 01                    AND  a, =RDRF_bm
1148: 6C 08                    BZ   isr_irq_send
114A: C2 01                    LD   a, ACIA_D, p2   ; receive character
114C: 26 00 20                 LD   p2, =rx_queue
114F: 20 F8 10                 JSR  queue_add
1152:          isr_irq_send:
1152: 38                       POP  a               ; restore ACIA status
1153: D4 02                    AND  a, =TDRE_bm
1155: 6C 18                    BZ   isr_irq_exit
1157: 26 10 20                 LD   p2, =tx_queue
115A: 20 16 11                 JSR  queue_remove
115D: 26 00 DF                 LD   p2, =ACIA
1160: 6C 05                    BZ   isr_irq_send_empty
1162: 40                       LD   a, e
1163: CA 01                    ST   a, ACIA_D, p2   ; send character
1165: 74 08                    BRA  isr_irq_exit
1167:          isr_irq_send_empty:
1167: C4 94                    LD   a, =RX_INT_TX_NO
1169: CA 00                    ST   a, ACIA_C, p2   ; disable Tx interrupt
116B: C4 00                    LD   a, =0
116D: CD 00                    ST   a, tx_int_control
116F:          isr_irq_exit:
116F: 5E                       POP  p2
1170: 3A                       POP  ea
1171: 3B 01                    OR   s, =S_IE
1173: 5C                       RET
1174:
   4:                          ORG  ORG_INTA
   4: 24 31 11                 JMP  isr_irq
   7:
   1:                          ORG  ORG_RESTART
   1: 24 FF 0F                 JMP  initialize
