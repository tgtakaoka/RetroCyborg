          0 :                            cpu     1802
          0 :                            include "cdp1802.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; CDP1802 register alias
(1)       0 : =0                 R0:     equ     0
(1)       0 : =1                 R1:     equ     1
(1)       0 : =2                 R2:     equ     2
(1)       0 : =3                 R3:     equ     3
(1)       0 : =4                 R4:     equ     4
(1)       0 : =5                 R5:     equ     5
(1)       0 : =6                 R6:     equ     6
(1)       0 : =7                 R7:     equ     7
(1)       0 : =8                 R8:     equ     8
(1)       0 : =9                 R9:     equ     9
(1)       0 : =A                 R10:    equ     10
(1)       0 : =B                 R11:    equ     11
(1)       0 : =C                 R12:    equ     12
(1)       0 : =D                 R13:    equ     13
(1)       0 : =E                 R14:    equ     14
(1)       0 : =F                 R15:    equ     15
(1)       0 :
(1)       0 :                    ;;; Transfer locations
(1)       0 : =0                 ORG_RESET:      equ     0000H   ; Reset transfer location
(1)       0 :
(1)       0 :                    ;;; Utility function
(1)       0 :                    hi:     function        v, v >> 8
(1)       0 :                    lo:     function        v, v & 0FFH
          0 :
          0 :                    ;;; MC6850 Asynchronous Communication Interface Adapter
          0 : =DF00              ACIA:   equ     0DF00H
          0 :                            include "mc6850.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; MC6850
(1)       0 :                    ;;; Asynchronous Communication Interface Adapter
(1)       0 :
(1)       0 :                    ;;; Control register
(1)       0 : =DF00              ACIA_control:   equ     ACIA+0
(1)       0 :                            ;; Counter Divider Select Bits
(1)       0 : =3                 CDS_gm:         equ     11b    ; Group mask
(1)       0 : =0                 CDS_DIV1_gc:    equ     00000000B ; /1
(1)       0 : =1                 CDS_DIV16_gc:   equ     00000001B ; /16
(1)       0 : =2                 CDS_DIV64_gc:   equ     00000010B ; /64
(1)       0 : =3                 CDS_RESET_gc:   equ     00000011B ; Master Reset
(1)       0 :                            ;; Word Select Bits
(1)       0 : =1C                WSB_gm:         equ     00011100B ; Group mask
(1)       0 : =0                 WSB_7E2_gc:     equ     00000000B ; 7 Bits + Even Parity + 2 Stop Bits
(1)       0 : =4                 WSB_7O2_gc:     equ     00000100B ; 7 bits + Odd Parity  + 2 Stop Bits
(1)       0 : =8                 WSB_7E1_gc:     equ     00001000B ; 7 bits + Even Parity + 1 Stop Bits
(1)       0 : =C                 WSB_7O1_gc:     equ     00001100B ; 7 bits + Odd Parity  + 1 Stop Bits
(1)       0 : =10                WSB_8N2_gc:     equ     00010000B ; 8 bits + No Parity   + 2 Stop Bits
(1)       0 : =14                WSB_8N1_gc:     equ     00010100B ; 8 bits + No Parity   + 1 Stop Bits
(1)       0 : =18                WSB_8E1_gc:     equ     00011000B ; 8 bits + Even Parity + 1 Stop Bits
(1)       0 : =1C                WSB_8O1_gc:     equ     00011100B ; 8 bits + Odd Parity  + 1 Stop Bits
(1)       0 :                            ;; Transmit Control Bits
(1)       0 : =60                TCB_gm:         equ     01100000B ; Group mask
(1)       0 : =0                 TCB_DI_gc:      equ     00000000B ; RTS=Low,  Tx Interrupt Disabled
(1)       0 : =20                TCB_EI_gc:      equ     00100000B ; RTS=Low,  Tx Interrupt Enabled
(1)       0 : =40                TCB_RTS_gc:     equ     01000000B ; RTS=High, Tx Interrupt Disabled
(1)       0 : =60                TCB_BREAK_gc:   equ     01100000B ; RTS=Low,  Tx Interrupt Disabled
(1)       0 :                                                      ; Transmit Break Level
(1)       0 : =80                RIEB_bm:        equ     10000000B ; Receive Interrupt Enable Bit mask
(1)       0 :
(1)       0 :                    ;;; Status register
(1)       0 : =DF00              ACIA_status:    equ     ACIA+0
(1)       0 : =1                 RDRF_bm:        equ     00000001B ; Receive Data Register Full
(1)       0 : =2                 TDRE_bm:        equ     00000010B ; Transmit Data Register Empty
(1)       0 : =4                 DCDF_bm:        equ     00000100B ; Data Carrier Detect Flag
(1)       0 : =8                 CTSF_bm:        equ     00001000B ; Clear To Send Flag
(1)       0 : =10                FERR_bm:        equ     00010000B ; Frame Error Flag
(1)       0 : =20                OVRN_bm:        equ     00100000B ; Receiver Overrun Flag
(1)       0 : =40                PERR_bm:        equ     01000000B ; Parity Error Flag
(1)       0 : =80                IRQF_bm:        equ     10000000B ; Interrupt Request Flag
(1)       0 :
(1)       0 :                    ;;; Data register
(1)       0 : =DF01              ACIA_data:      equ     ACIA+1          ; Data register
          0 :
       2000 :                            org     2000H
       2000 :
       2000 : =10                rx_queue_size:  equ     16
       2000 : =30                tx_queue_size:  equ     48
       2000 : =94                RX_INT_TX_NO:   equ     WSB_8N1_gc|RIEB_bm
       2000 : =B4                RX_INT_TX_INT:  equ     WSB_8N1_gc|RIEB_bm|TCB_EI_gc
       2000 :
       2000 :                    rx_queue:
       2000 :                            ds      rx_queue_size
       2010 :                    tx_queue:
       2010 :                            ds      tx_queue_size
       2040 :                    tx_int_control:
       2040 :                            ds      1
       2041 :
       2041 : =FFF               stack:  equ     1000H-1
       2041 :
        100 :                            org     0100H
        100 :                    main:
        100 : D4                         sep     R4
        101 : 01 DE                      dw      queue_init      ; call queue_init
        103 : 20 00                      dw      rx_queue
        105 : 10                         db      rx_queue_size
        106 : D4                         sep     R4
        107 : 01 DE                      dw      queue_init      ; call queue_init
        109 : 20 10                      dw      tx_queue
        10B : 30                         db      tx_queue_size
        10C :                            ;; initialize ACIA
        10C : F8 DF                      ldi     hi(ACIA)
        10E : B8                         phi     R8
        10F : F8 00                      ldi     lo(ACIA)
        111 : A8                         plo     R8
        112 : F8 03                      ldi     CDS_RESET_gc    ; Master reset
        114 : 58                         str     R8              ; ACIA_control
        115 : F8 94                      ldi     RX_INT_TX_NO
        117 : 58                         str     R8              ; ACIA_control
        118 :                            ;; initialize tx_int_control
        118 : F8 20                      ldi     hi(tx_int_control)
        11A : B8                         phi     R8
        11B : F8 40                      ldi     lo(tx_int_control)
        11D : A8                         plo     R8
        11E : F8 00                      ldi     0
        120 : 58                         str     R8              ; disable Tx interrupt
        121 : E3                         sex     R3
        122 : 70                         ret
        123 : 33                         db      33h             ; enable interrupt
        124 :
        124 :                    loop:
        124 : D4                         sep     R4              ; call getchar
        125 : 01 9F                      dw      getchar
        127 : 32 24                      bz      loop
        129 : 87                         glo     R7
        12A : D4                         sep     R4              ; call putchar
        12B : 01 AB                      dw      putchar
        12D : F8 20                      ldi     ' '
        12F : D4                         sep     R4              ; call putchar
        130 : 01 AB                      dw      putchar
        132 : 87                         glo     R7
        133 : D4                         sep     R4              ; call put_hex8
        134 : 01 4C                      dw      put_hex8
        136 : F8 20                      ldi     ' '
        138 : D4                         sep     R4              ; call putchar
        139 : 01 AB                      dw      putchar
        13B : 87                         glo     R7
        13C : D4                         sep     R4              ; call put_bin8
        13D : 01 7C                      dw      put_bin8
        13F : F8 0D                      ldi     x'0d'
        141 : D4                         sep     R4              ; call putchar
        142 : 01 AB                      dw      putchar
        144 : F8 0A                      ldi     x'0a'
        146 : D4                         sep     R4              ; call putchar
        147 : 01 AB                      dw      putchar
        149 : C0 01 24                   lbr     loop
        14C :
        14C :                    ;;; Print uint8_t in hex
        14C :                    ;;; @param D uint8_t value to be printed in binary.
        14C :                    put_hex8:
        14C : AF                         plo     R15             ; save D to scratch pad
        14D : E2                         sex     R2
        14E : 87                         glo     R7              ; save R7.0
        14F : 73                         stxd
        150 : 8F                         glo     R15             ; restore D
        151 :                            ;;
        151 : A7                         plo     R7              ; R7.0=data
        152 : F8 30                      ldi     '0'
        154 : D4                         sep     R4              ; call putchar
        155 : 01 AB                      dw      putchar
        157 : F8 78                      ldi     'x'
        159 : D4                         sep     R4              ; call putchar
        15A : 01 AB                      dw      putchar
        15C : 87                         glo     R7
        15D : F6                         shr
        15E : F6                         shr
        15F : F6                         shr
        160 : F6                         shr
        161 : D4                         sep     R4              ; call put_hex4
        162 : 01 6D                      dw      put_hex4
        164 : 87                         glo     R7
        165 : D4                         sep     R4              ; call put_hex4
        166 : 01 6D                      dw      put_hex4
        168 :                            ;;
        168 : E2                         sex     R2
        169 : 60                         irx
        16A : F0                         ldx                     ; restore R7.0
        16B : A7                         plo     R7
        16C : D5                         sep     R5              ; return
        16D :
        16D :                    ;;; Print hexadecimal digit
        16D :                    ;;; @param D nibble
        16D :                    ;;; @clobber D
        16D :                    put_hex4:
        16D : FA 0F                      ani     0Fh
        16F : FF 0A                      smi     10
        171 : 3B 76                      bnf     put_hex4_dec    ; branch if D < 10
        173 : FC 41                      adi     'A'
        175 : C8                         lskp
        176 :                    put_hex4_dec:
        176 : FC 3A                      adi     '0'+10
        178 : D4                         sep     R4              ; call putchar
        179 : 01 AB                      dw      putchar
        17B : D5                         sep     R5              ; return
        17C :
        17C :                    ;;; Print uint8_t in binary
        17C :                    ;;; @param D uint8_t value to be printed in binary.
        17C :                    ;;; @clobber D
        17C :                    put_bin8:
        17C : AF                         plo     R15             ; save D to scratch pad
        17D : E2                         sex     R2
        17E : 87                         glo     R7              ; save R7
        17F : 73                         stxd
        180 : 97                         ghi     R7
        181 : 73                         stxd
        182 : 8F                         glo     R15             ; restore D
        183 :                            ;;
        183 : B7                         phi     R7              ; R7.1=data
        184 : F8 08                      ldi     8
        186 : A7                         plo     R7              ; R7.0=bit count
        187 :                    put_bin8_loop:
        187 : 97                         ghi     R7
        188 : FE                         shl
        189 : B7                         phi     R7              ; R7.1<<=1
        18A : 3B 8F                      bnf     put_bin8_zero
        18C : F8 31                      ldi     '1'
        18E : C8                         lskp
        18F :                    put_bin8_zero:
        18F : F8 30                      ldi     '0'
        191 : D4                         sep     R4              ; call putchar
        192 : 01 AB                      dw      putchar
        194 : 27                         dec     R7              ; R7--
        195 : 87                         glo     R7
        196 : 3A 87                      bnz     put_bin8_loop
        198 :                            ;;
        198 : E2                         sex     R2
        199 : 60                         irx
        19A : 72                         ldxa                    ; restore R7
        19B : B7                         phi     R7
        19C : F0                         ldx
        19D : A7                         plo     R7
        19E : D5                         sep     R5              ; return
        19F :
        19F :                    ;;; Get character
        19F :                    ;;; @return R7.0 char
        19F :                    ;;; @return A 0 if no char received
        19F :                    getchar:
        19F : E3                         sex     R3
        1A0 : 71                         dis                     ; disable interrupt
        1A1 : 33                         db      33h
        1A2 : D4                         sep     R4              ; call queue_remove
        1A3 : 02 3B                      dw      queue_remove
        1A5 : 20 00                      dw      rx_queue
        1A7 : E3                         sex     R3
        1A8 : 70                         ret                     ; enable interrupt
        1A9 : 33                         db      33h
        1AA : D5                         sep     R5              ; return
        1AB :
        1AB :                    ;;; Put character
        1AB :                    ;;; @param D char
        1AB :                    ;;; @clobber D
        1AB :                    putchar:
        1AB : AF                         plo     R15             ; save D to scratch pad
        1AC : E2                         sex     R2
        1AD : 87                         glo     R7              ; save R7.0
        1AE : 73                         stxd
        1AF : 8F                         glo     R15             ; restore D
        1B0 :                            ;;
        1B0 : A7                         plo     R7              ; R7.0=char
        1B1 :                    putchar_loop:
        1B1 : E3                         sex     R3
        1B2 : 71                         dis                     ; disable interrupt
        1B3 : 33                         db      33h
        1B4 : D4                         sep     R4              ; call queue_add
        1B5 : 01 FE                      dw      queue_add
        1B7 : 20 10                      dw      tx_queue
        1B9 : E3                         sex     R3
        1BA : 70                         ret                     ; enable interrupt
        1BB : 33                         db      33h
        1BC : 32 B1                      bz      putchar_loop    ; retry if queue is full
        1BE : E3                         sex     R3
        1BF : 71                         dis                     ; disable interrupt
        1C0 : 33                         db      33h
        1C1 : F8 20                      ldi     hi(tx_int_control)
        1C3 : BF                         phi     R15
        1C4 : F8 40                      ldi     lo(tx_int_control)
        1C6 : AF                         plo     R15
        1C7 : 0F                         ldn     R15
        1C8 : 3A D9                      bnz     putchar_exit    ; branch if Tx interrupt enabled
        1CA : F8 01                      ldi     1
        1CC : 5F                         str     R15             ; mark enable Tx interrupt
        1CD : F8 DF                      ldi     hi(ACIA)
        1CF : BF                         phi     R15
        1D0 : F8 00                      ldi     lo(ACIA)
        1D2 : AF                         plo     R15
        1D3 : F8 B4                      ldi     RX_INT_TX_INT   ; enable Tx interrupt
        1D5 : 5F                         str     R15             ; ACIA_C
        1D6 : E3                         sex     R3
        1D7 : 70                         ret                     ; enable interrupt
        1D8 : 33                         db      33h
        1D9 :                    putchar_exit:
        1D9 : E2                         sex     R2
        1DA : 60                         irx
        1DB : F0                         ldx                     ; restore R7.0
        1DC : A7                         plo     R7
        1DD : D5                         sep     R5              ; return
        1DE :
        1DE :                            include "queue.inc"
(1)     1DE :                    ;;; [queue] queue structure
(1)     1DE : =0                 queue_len:      equ     0       ; queue length
(1)     1DE : =1                 queue_size:     equ     1       ; buffer size
(1)     1DE : =2                 queue_put:      equ     2       ; queue put index
(1)     1DE : =3                 queue_get:      equ     3       ; queue get index
(1)     1DE : =4                 queue_buf:      equ     4       ; buffer start offset
(1)     1DE :
(1)     1DE :                    ;;; [queue] Initialize queue
(1)     1DE :                    ;;; @param R6+0 queue work space pointer
(1)     1DE :                    ;;; @param R6+2 queue work space size
(1)     1DE :                    ;;; @clobber D, R15
(1)     1DE :                    queue_init:
(1)     1DE : E2                         sex     R2
(1)     1DF : 8E                         glo     R14             ; save R14.0
(1)     1E0 : 73                         stxd
(1)     1E1 :                            ;;
(1)     1E1 : 46                         lda     R6
(1)     1E2 : BF                         phi     R15
(1)     1E3 : 46                         lda     R6
(1)     1E4 : AF                         plo     R15             ; R15=queue space pointer
(1)     1E5 : F8 00                      ldi     0
(1)     1E7 : 5F                         str     R15             ; clear queue_len
(1)     1E8 : 1F                         inc     R15
(1)     1E9 : 46                         lda     R6              ; queue space size
(1)     1EA : FF 04                      smi     queue_buf       ; calculate queue size
(1)     1EC : 5F                         str     R15             ; store queue_size
(1)     1ED : FC 02                      adi     2               ; for queue_put and queue_get
(1)     1EF : AE                         plo     R14             ; R14.0: byte counter
(1)     1F0 :                    queue_init_clear:
(1)     1F0 : F8 00                      ldi     0
(1)     1F2 : 1F                         inc     R15
(1)     1F3 : 5F                         str     R15             ; clear memory
(1)     1F4 : 8E                         glo     R14
(1)     1F5 : FF 01                      smi     1
(1)     1F7 : AE                         plo     R14             ; decrement byte counter
(1)     1F8 : 3A F0                      bnz     queue_init_clear
(1)     1FA :                            ;;
(1)     1FA : 60                         irx
(1)     1FB : F0                         ldx                     ; restore R14.0
(1)     1FC : AE                         plo     R14
(1)     1FD : D5                         sep     R5              ; return
(1)     1FE :
(1)     1FE :                    ;;; [queue] Add an element to queue
(1)     1FE :                    ;;; @param R6+0 queue work space pointer
(1)     1FE :                    ;;; @param R7.0 an element
(1)     1FE :                    ;;; @return D 0 if queue is full
(1)     1FE :                    queue_add:
(1)     1FE : E2                         sex     R2
(1)     1FF : 8E                         glo     R14             ; save R14
(1)     200 : 73                         stxd
(1)     201 : 9E                         ghi     R14
(1)     202 : 73                         stxd
(1)     203 :                            ;;
(1)     203 : 46                         lda     R6
(1)     204 : BF                         phi     R15
(1)     205 : 46                         lda     R6
(1)     206 : AF                         plo     R15             ; R15=queue space pointer
(1)     207 : EF                         sex     R15
(1)     208 : 72                         ldxa                    ; load queue_len
(1)     209 : F3                         xor                     ; queue_len ^ queue_size
(1)     20A : C2 02 32                   lbz     queue_add_return ; branch if D=0
(1)     20D : 2F                         dec     R15
(1)     20E : 8F                         glo     R15
(1)     20F : FC 04                      adi     queue_buf
(1)     211 : AE                         plo     R14
(1)     212 : 9F                         ghi     R15
(1)     213 : 7C 00                      adci    0
(1)     215 : BE                         phi     R14             ; R14=&queue_buf[0]
(1)     216 : 0F                         ldn     R15
(1)     217 : FC 01                      adi     1
(1)     219 : 5F                         str     R15             ; queue_len++
(1)     21A : 8E                         glo     R14
(1)     21B : 1F                         inc     R15
(1)     21C : 1F                         inc     R15
(1)     21D : EF                         sex     R15
(1)     21E : F4                         add                     ; add queue_put
(1)     21F : AE                         plo     R14
(1)     220 : 9E                         ghi     R14
(1)     221 : 7C 00                      adci    0
(1)     223 : BE                         phi     R14             ; R14=&queue_buf[queue_put]
(1)     224 : 87                         glo     R7              ; R7.0=an element
(1)     225 : 5E                         str     R14             ; store an element
(1)     226 : 0F                         ldn     R15             ; load queue_put
(1)     227 : FC 01                      adi     1
(1)     229 : 5F                         str     R15             ; update queue_put
(1)     22A : 2F                         dec     R15
(1)     22B : F3                         xor                      ; queue_put ^ queue_size
(1)     22C : 3A 32                      bnz     queue_add_return ; branch if D!=0
(1)     22E : 1F                         inc     R15
(1)     22F : 5F                         str     R15             ; queue_put=0
(1)     230 : F8 01                      ldi     1
(1)     232 :                    queue_add_return:
(1)     232 : AF                         plo     R15             ; return flag
(1)     233 : E2                         sex     R2
(1)     234 : 60                         irx
(1)     235 : 72                         ldxa                    ; restore R14
(1)     236 : BE                         phi     R14
(1)     237 : F0                         ldx
(1)     238 : AE                         plo     R14
(1)     239 : 8F                         glo     R15
(1)     23A : D5                         sep     R5              ; return
(1)     23B :
(1)     23B :                    ;;; [queue] Remove an element from queue
(1)     23B :                    ;;; @param R6+0 queue work space pointer
(1)     23B :                    ;;; @return R7.0 an element
(1)     23B :                    ;;; @return D 0 if queue is empty
(1)     23B :                    ;;; @clobber R15
(1)     23B :                    queue_remove:
(1)     23B : E2                         sex     R2
(1)     23C : 8E                         glo     R14             ; save R14
(1)     23D : 73                         stxd
(1)     23E : 9E                         ghi     R14
(1)     23F : 73                         stxd
(1)     240 :                            ;;
(1)     240 : 46                         lda     R6
(1)     241 : BF                         phi     R15
(1)     242 : 46                         lda     R6
(1)     243 : AF                         plo     R15             ; R15=queue space pointer
(1)     244 : 0F                         ldn     R15             ; load queue_len
(1)     245 : 32 6D                      bz      queue_remove_return ; branch if D=0
(1)     247 : FF 01                      smi     1
(1)     249 : 5F                         str     R15             ; queue_len--
(1)     24A : 8F                         glo     R15
(1)     24B : FC 04                      adi     queue_buf
(1)     24D : AE                         plo     R14
(1)     24E : 9F                         ghi     R15
(1)     24F : 7C 00                      adci    0
(1)     251 : BE                         phi     R14             ; R14=&queue_buf[0]
(1)     252 : 8E                         glo     R14
(1)     253 : 1F                         inc     R15
(1)     254 : 1F                         inc     R15
(1)     255 : 1F                         inc     R15
(1)     256 : EF                         sex     R15
(1)     257 : F4                         add                     ; add queue_get
(1)     258 : AE                         plo     R14
(1)     259 : 9E                         ghi     R14
(1)     25A : 7C 00                      adci    0
(1)     25C : BE                         phi     R14             ; R14=&queue_buf[queue_get]
(1)     25D : 0E                         ldn     R14             ; load an alement
(1)     25E : A7                         plo     R7              ; R7.0=an element
(1)     25F : 0F                         ldn     R15             ; load queue_get
(1)     260 : FC 01                      adi     1
(1)     262 : 5F                         str     R15             ; update queue_get
(1)     263 : 2F                         dec     R15
(1)     264 : 2F                         dec     R15
(1)     265 : F3                         xor                     ; queue_get ^ queue_size
(1)     266 : 3A 6D                      bnz     queue_remove_return ; brnach if D!=0
(1)     268 : 1F                         inc     R15
(1)     269 : 1F                         inc     R15
(1)     26A : 5F                         str     R15             ; queue_get=0
(1)     26B : F8 01                      ldi     1
(1)     26D :                    queue_remove_return:
(1)     26D : AF                         plo     R15             ; return flag
(1)     26E : E2                         sex     R2
(1)     26F : 60                         irx
(1)     270 : 72                         ldxa                    ; restore R14
(1)     271 : BE                         phi     R14
(1)     272 : F0                         ldx
(1)     273 : AE                         plo     R14
(1)     274 : 8F                         glo     R15             ; return flag
(1)     275 : D5                         sep     R5              ; return
(1)     276 :
(1)     276 :                    ;;; Local Variables:
(1)     276 :                    ;;; mode: asm
(1)     276 :                    ;;; End:
(1)     276 :                    ;;; vim: set ft=asm et ts=4 sw=4:
        276 :
        276 :                    ;;; From scrt_isr, X=2, P=3
        276 :                    isr:
        276 : 88                         glo     R8              ; save R8
        277 : 73                         stxd
        278 : 98                         ghi     R8
        279 : 73                         stxd
        27A : 87                         glo     R7              ; save R7
        27B : 73                         stxd
        27C : 97                         ghi     R7
        27D : 73                         stxd
        27E :                            ;;
        27E : F8 DF                      ldi     hi(ACIA)
        280 : B8                         phi     R8
        281 : F8 00                      ldi     lo(ACIA)
        283 : A8                         plo     R8              ; R8=ACIA
        284 : 08                         ldn     R8              ; ACIA_status
        285 : B7                         phi     R7              ; R7.1=status
        286 : FA 70                      ani     FERR_bm|OVRN_bm|PERR_bm
        288 : 32 8D                      bz      isr_receive
        28A : 18                         inc     R8
        28B : 08                         ldn     R8              ; clear error
        28C : 28                         dec     R8
        28D :                    isr_receive:
        28D : 97                         ghi     R7
        28E : FA 01                      ani     RDRF_bm
        290 : 32 9B                      bz      isr_send        ; no data is received
        292 : 18                         inc     R8
        293 : 08                         ldn     R8              ; ACIA_data
        294 : 28                         dec     R8
        295 : A7                         plo     R7
        296 : D4                         sep     R4              ; call queue_add
        297 : 01 FE                      dw      queue_add
        299 : 20 00                      dw      rx_queue
        29B :                    isr_send:
        29B : 97                         ghi     R7
        29C : FA 02                      ani     TDRE_bm
        29E : 32 B9                      bz      isr_exit
        2A0 : D4                         sep     R4              ; call queue_remove
        2A1 : 02 3B                      dw      queue_remove
        2A3 : 20 10                      dw      tx_queue
        2A5 : 32 AD                      bz      isr_send_empty
        2A7 : 87                         glo     R7
        2A8 : 18                         inc     R8
        2A9 : 58                         str     R8              ; ACIA_D
        2AA : 28                         dec     R8
        2AB : 30 B9                      br      isr_exit
        2AD :                    isr_send_empty:
        2AD : F8 94                      ldi     RX_INT_TX_NO    ; disable Tx interrupt
        2AF : 58                         str     R8              ; ACIA_C
        2B0 : F8 20                      ldi     hi(tx_int_control)
        2B2 : B8                         phi     R8
        2B3 : F8 40                      ldi     lo(tx_int_control)
        2B5 : A8                         plo     R8
        2B6 : F8 00                      ldi     0
        2B8 : 58                         str     R8              ; mark Tx interrupt disabled
        2B9 :                    isr_exit:
        2B9 : E2                         sex     R2
        2BA : 60                         irx
        2BB : 72                         ldxa                    ; restore R7
        2BC : B7                         phi     R7
        2BD : 72                         ldxa
        2BE : A7                         plo     R7
        2BF : 72                         ldxa                    ; restore R8
        2C0 : B8                         phi     R8
        2C1 : F0                         ldx
        2C2 : A8                         plo     R8
        2C3 : D1                         sep     R1              ; return to scrt_isr
        2C4 :
          0 :                            org     ORG_RESET
          0 : 71                         dis                     ; disable interrupt
          1 : 00                         db      00h             ; X:P=0:0
          2 : C0 00 05                   lbr     scrt_init
          5 :
          5 :                            include "scrt.inc"
(1)       5 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       5 :
(1)       5 :                    ;;; Standard Call and Return Technique
(1)       5 :                    ;;; R0: DMA pointer
(1)       5 :                    ;;; R1: Program counter for Interrupt routine
(1)       5 :                    ;;; R2: Stack pointer
(1)       5 :                    ;;; R3: Program counter
(1)       5 :                    ;;; R4: Dedicated program counter for CALL routine
(1)       5 :                    ;;; R5: Dedicated program counter for RETURN routine
(1)       5 :                    ;;; R6: Link register, pointer to the return location and arguments
(1)       5 :                    ;;;     passed by the calling program
(1)       5 :
(1)       5 :                    ;;; Call subroutine
(1)       5 :                    ;;;   SEP R4
(1)       5 :                    ;;;   DW  subroutine
(1)       5 :                    ;;;   DB  arguments...
(1)       5 :                    ;;; Subroutine return
(1)       5 :                    ;;;   SEP R5
(1)       5 :                    ;;; Return from interrupt
(1)       5 :                    ;;;   SEP R1
(1)       5 :
(1)       5 :                    ;;; Initialize for SCRT, P=0
(1)       5 :                    ;;; @param P!=3
(1)       5 :                    ;;; @param stack top address of stack
(1)       5 :                    ;;; @param main start address of main routine
(1)       5 :                    ;;; @return P=3
(1)       5 :                    ;;; @return R1=scrt_isr
(1)       5 :                    ;;; @return R2=stack
(1)       5 :                    ;;; @return R3=main
(1)       5 :                    ;;; @return R4=scrt_call
(1)       5 :                    ;;; @return R5=scrt_return
(1)       5 :                    ;;; @clobber D, R15
(1)       5 :                    scrt_init:
(1)       5 : F8 00                      ldi     hi(scrt_start)
(1)       7 : B3                         phi     R3
(1)       8 : F8 0C                      ldi     lo(scrt_start)
(1)       A : A3                         plo     R3
(1)       B : D3                         sep     R3              ; P=3
(1)       C :                    scrt_start:
(1)       C : F8 00                      ldi     hi(scrt_init_tab)
(1)       E : BF                         phi     R15
(1)       F : F8 25                      ldi     lo(scrt_init_tab)
(1)      11 : AF                         plo     R15
(1)      12 : 4F                         lda     R15             ; setup interrupt
(1)      13 : B1                         phi     R1
(1)      14 : 4F                         lda     R15
(1)      15 : A1                         plo     R1
(1)      16 : 4F                         lda     R15             ; setup stack
(1)      17 : B2                         phi     R2
(1)      18 : 4F                         lda     R15
(1)      19 : A2                         plo     R2
(1)      1A : 4F                         lda     R15             ; setup call
(1)      1B : B4                         phi     R4
(1)      1C : 4F                         lda     R15
(1)      1D : A4                         plo     R4
(1)      1E : 4F                         lda     R15             ; setup return
(1)      1F : B5                         phi     R5
(1)      20 : 4F                         lda     R15
(1)      21 : A5                         plo     R5
(1)      22 : C0 01 00                   lbr     main            ; goto main with P=3
(1)      25 :
(1)      25 :                    scrt_init_tab:
(1)      25 : 00 64                      dw      scrt_isr        ; R1
(1)      27 : 0F FF                      dw      stack           ; R2
(1)      29 : 00 2E                      dw      scrt_call       ; R4
(1)      2B : 00 40                      dw      scrt_return     ; R5
(1)      2D :
(1)      2D :                    ;;; Call subroutine, P=4
(1)      2D :                    ;;; @param M(R3):M(R3+1) subroutine address
(1)      2D :                    ;;; @param M(R3+2) optional arguments, depending on a subroutine called.
(1)      2D :                    ;;; @return R6 points optional arguments
(1)      2D :                    ;;; @return M(R2) R6.1, R6.0
(1)      2D :                    ;;; @clobber R15.1, X
(1)      2D :                    ;;; @unchanged D, IE, R0, R1, R7-R14, R15.0
(1)      2D :                    scrt_call_exit:
(1)      2D : D3                         sep     R3              ; go to subroutine
(1)      2E :                    scrt_call:
(1)      2E : BF                         phi     R15             ; save D to R15.1
(1)      2F : E2                         sex     R2              ; select stack
(1)      30 : 86                         glo     R6              ; push old link register R6
(1)      31 : 73                         stxd
(1)      32 : 96                         ghi     R6
(1)      33 : 73                         stxd
(1)      34 : 93                         ghi     R3              ; load link register
(1)      35 : B6                         phi     R6
(1)      36 : 83                         glo     R3
(1)      37 : A6                         plo     R6
(1)      38 : 46                         lda     R6              ; load the address of subroutine
(1)      39 : B3                         phi     R3
(1)      3A : 46                         lda     R6
(1)      3B : A3                         plo     R3              ; R3=subroutine address
(1)      3C : 9F                         ghi     R15             ; restore D
(1)      3D : 30 2D                      br      scrt_call_exit
(1)      3F :
(1)      3F :                    ;;; Return subroutine, P=5
(1)      3F :                    ;;; @param R6 return address
(1)      3F :                    ;;; @oaram M(R2) R6.1, R6.0, X:P(3)
(1)      3F :                    ;;; @clobber R15.1, X
(1)      3F :                    ;;; @unchanged D, R0, R1, R7-R14, R15.0
(1)      3F :                    scrt_return_exit:
(1)      3F : D3                         sep     R3              ; return to subroutine caller
(1)      40 :                    scrt_return:
(1)      40 : BF                         phi     R15             ; save D to R15.1
(1)      41 : 96                         ghi     R6              ; load return address from link register
(1)      42 : B3                         phi     R3
(1)      43 : 86                         glo     R6
(1)      44 : A3                         plo     R3
(1)      45 : E2                         sex     R2              ; select stack
(1)      46 : 60                         irx
(1)      47 : 72                         ldxa                    ; pop link register R6
(1)      48 : B6                         phi     R6
(1)      49 : F0                         ldx
(1)      4A : A6                         plo     R6
(1)      4B : 9F                         ghi     R15             ; restore D
(1)      4C : 30 3F                      br      scrt_return_exit
(1)      4E :
(1)      4E :                    ;;; Interrupt entry P=1
(1)      4E :                    ;;; @unchanged D, DF, X, P, R3, R6, R15
(1)      4E :                    scrt_isr_exit:
(1)      4E : E2                         sex     R2              ; select stack
(1)      4F : 60                         irx
(1)      50 : 72                         ldxa                    ; pop program counter R3
(1)      51 : B3                         phi     R3
(1)      52 : 72                         ldxa
(1)      53 : A3                         plo     R3
(1)      54 : 72                         ldxa                    ; pop call pointer R4
(1)      55 : B4                         phi     R4
(1)      56 : 72                         ldxa
(1)      57 : A4                         plo     R4
(1)      58 : 72                         ldxa                    ; pop return pointer R5
(1)      59 : B5                         phi     R5
(1)      5A : 72                         ldxa
(1)      5B : A5                         plo     R5
(1)      5C : 72                         ldxa                    ; pop scratch pad register R15
(1)      5D : BF                         phi     R15
(1)      5E : 72                         ldxa
(1)      5F : AF                         plo     R15
(1)      60 : 72                         ldxa                    ; pop DF into BSB
(1)      61 : FE                         shl                     ; restore DF
(1)      62 : 72                         ldxa                    ; pop D
(1)      63 : 70                         ret                     ; restore X,P IE=1
(1)      64 :                            ;; P1 points scrt_isr
(1)      64 :                    ;;; CDP1802 interrupt entry, X=2, P=1, IE=0
(1)      64 :                    scrt_isr:
(1)      64 :                            ;; R2[0] must be preserved because it may be in the pop process
(1)      64 : 22                         dec     R2
(1)      65 : 78                         sav                     ; push X,P
(1)      66 : 22                         dec     R2
(1)      67 : 73                         stxd                    ; push D
(1)      68 : 76                         shrc                    ; MSB of D=DF
(1)      69 : 73                         stxd                    ; push DF
(1)      6A : 8F                         glo     R15             ; push scratch pad register R15
(1)      6B : 73                         stxd
(1)      6C : 9F                         ghi     R15
(1)      6D : 73                         stxd
(1)      6E : 85                         glo     R5              ; push return pointer R5
(1)      6F : 73                         stxd
(1)      70 : 95                         ghi     R5
(1)      71 : 73                         stxd
(1)      72 : 84                         glo     R4              ; push call pointer R4
(1)      73 : 73                         stxd
(1)      74 : 94                         ghi     R4
(1)      75 : 73                         stxd
(1)      76 : 83                         glo     R3              ; push program counter R3
(1)      77 : 73                         stxd
(1)      78 : 93                         ghi     R3
(1)      79 : 73                         stxd
(1)      7A :                            ;;
(1)      7A : F8 00                      ldi     hi(scrt_call)  ; initialize call pointer R4
(1)      7C : B4                         phi     R4
(1)      7D : F8 2E                      ldi     lo(scrt_call)
(1)      7F : A4                         plo     R4
(1)      80 : F8 00                      ldi     hi(scrt_return) ; initialize return pointer R5
(1)      82 : B5                         phi     R5
(1)      83 : F8 40                      ldi     lo(scrt_return)
(1)      85 : A5                         plo     R5
(1)      86 :                            ;;
(1)      86 : F8 02                      ldi     hi(isr)
(1)      88 : B3                         phi     R3
(1)      89 : F8 76                      ldi     lo(isr)
(1)      8B : A3                         plo     R3
(1)      8C : D3                         sep     R3              ; call interrupt service routine with P=3
(1)      8D : 30 4E                      br      scrt_isr_exit   ; return from isr by SEP P1
